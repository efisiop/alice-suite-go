{{define "title"}}Reader Inspector - Consultant Dashboard - Alice Suite{{end}}

{{define "nav"}}
<li class="nav-item">
    <a class="nav-link" href="/consultant">Dashboard</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/consultant/help-requests">Help Requests</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/consultant/readers">Readers</a>
</li>
<li class="nav-item">
    <a class="nav-link active" href="#" id="reader-inspector-link">Reader Inspector</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="#" id="logout-link" onclick="if(window.consultantLogout){window.consultantLogout();}else if(window.logout){window.logout();}else{window.location.href='/consultant/login';} return false;">Logout</a>
</li>
{{end}}

{{define "head"}}
<style>
.stat-card {
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    background-color: #f8f9fa;
    transition: box-shadow 0.2s;
}

.stat-card:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.stat-label {
    font-size: 0.875rem;
    color: #6c757d;
    margin-bottom: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 500;
}

.stat-value {
    font-size: 2rem;
    font-weight: 600;
    color: #495057;
}

.stat-value-small {
    font-size: 1.25rem;
    font-weight: 500;
    color: #495057;
}

.activity-timeline {
    max-height: 500px;
    overflow-y: auto;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 1rem;
    background-color: #ffffff;
}

.activity-item {
    border-left: 3px solid #007bff;
    padding: 0.75rem 1rem;
    margin-bottom: 0.75rem;
    background-color: #f8f9fa;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.activity-item:hover {
    background-color: #e9ecef;
}

.activity-item .activity-time {
    font-size: 0.75rem;
    color: #6c757d;
    margin-bottom: 0.25rem;
}

.activity-item .activity-detail {
    font-size: 0.875rem;
    color: #495057;
}

.loading-state {
    text-align: center;
    padding: 3rem;
}

.back-button {
    margin-bottom: 1.5rem;
}

/* AI Response Formatting */
.ai-response-content {
    line-height: 1.7;
    font-size: 0.95rem;
}

.ai-response-content p {
    margin-bottom: 1rem;
}

.ai-response-content p:last-child {
    margin-bottom: 0;
}

.ai-response-content strong {
    font-weight: 600;
    color: #0056b3;
}

.ai-response-content em {
    font-style: italic;
    color: #6c757d;
}

.ai-response-content br {
    line-height: 1.8;
}
</style>
{{end}}

{{define "content"}}
<div class="container-fluid">
    <div class="back-button">
        <a href="/consultant/readers" class="btn btn-outline-secondary">
            ‚Üê Back to Readers
        </a>
    </div>
    
    <div id="loadingState" class="loading-state">
        <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3">Loading reader details...</p>
    </div>
    
    <div id="contentArea" style="display: none;">
        <h1 class="mb-4" id="pageTitle">Reader Inspector</h1>
        
        <!-- Basic Info Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h5 class="mb-0">Reader Information</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Name</div>
                            <div class="stat-value-small" id="readerName">-</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Email</div>
                            <div class="stat-value-small" id="readerEmail">-</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Account Created</div>
                            <div class="stat-value-small" id="readerCreated">-</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Account Status</div>
                            <div class="stat-value-small" id="readerStatus">-</div>
                        </div>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-md-6">
                        <div class="stat-card">
                            <div class="stat-label">Book Purchase Date</div>
                            <div class="d-flex align-items-center gap-2">
                                <input type="date" class="form-control form-control-sm" id="purchaseDateInput" style="max-width: 200px;">
                                <button class="btn btn-sm btn-primary" onclick="savePurchaseDate()">Save</button>
                                <span class="text-muted" id="purchaseDateDisplay">Not set</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Activity Summary Section -->
        <div class="card mb-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Activity Summary (Last 30 Days)</h5>
                <small class="text-muted" id="lastUpdated">Last updated: -</small>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Total Activities</div>
                            <div class="stat-value" id="totalActivities">0</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Active Days</div>
                            <div class="stat-value" id="activeDays">0</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Word Lookups</div>
                            <div class="stat-value" id="wordLookups">0</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stat-card">
                            <div class="stat-label">Page Views</div>
                            <div class="stat-value" id="pageViews">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Recent Activities Section -->
        <div class="card mb-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Recent Activities</h5>
                <button class="btn btn-sm btn-outline-primary" onclick="refreshAll()">Refresh All</button>
            </div>
            <div class="card-body">
                <div class="activity-timeline" id="activitiesTimeline">
                    <p class="text-muted">Loading activities...</p>
                </div>
            </div>
        </div>

        <!-- AI Interactions Section -->
        <div class="card mb-4">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">ü§ñ AI Interactions</h5>
                <button class="btn btn-sm btn-light" onclick="loadAIInteractions()">Refresh</button>
            </div>
            <div class="card-body">
                <div id="aiInteractionsContainer" style="max-height: 600px; overflow-y: auto;">
                    <p class="text-muted">Loading AI interactions...</p>
                </div>
            </div>
        </div>

        <!-- Help Requests Section -->
        <div class="card mb-4">
            <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">üÜò Help Requests</h5>
                <button class="btn btn-sm btn-light" onclick="loadHelpRequests()">Refresh</button>
            </div>
            <div class="card-body">
                <div id="helpRequestsContainer" style="max-height: 600px; overflow-y: auto;">
                    <p class="text-muted">Loading help requests...</p>
                </div>
            </div>
        </div>
    </div>
</div>
{{end}}

{{define "scripts"}}
<script>
// Consultant logout function
(function() {
    // Store consultant logout function separately to prevent override
    window.consultantLogout = function() {
        console.log('[consultant-logout] Consultant logout called');
        
        // Hide user info immediately
        const userInfoNav = document.getElementById('user-info-nav');
        if (userInfoNav) {
            userInfoNav.style.display = 'none';
        }
        
        // Hide name in navbar brand as well
        const userNameBrand = document.getElementById('user-name-brand');
        if (userNameBrand) {
            userNameBrand.style.display = 'none';
            userNameBrand.textContent = '';
        }
        
        sessionStorage.removeItem('auth_token');
        // Clear auth cookie
        document.cookie = 'auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; SameSite=Lax';
        
        // Close SSE connection if exists
        if (window.sseConnection) {
            try {
                window.sseConnection.close();
            } catch(e) {}
            window.sseConnection = null;
        }
        
        // Always redirect to consultant login
        window.location.href = '/consultant/login';
    };
    
    // Override window.logout for consultant pages
    window.logout = window.consultantLogout;
})();

const readerId = '{{.ReaderID}}';

// Ensure getAuthToken is available
if (typeof getAuthToken === 'undefined') {
    window.getAuthToken = function() {
        return sessionStorage.getItem('auth_token');
    };
}

// Auto-refresh interval (30 seconds)
let refreshInterval = null;

// Logout handler
document.addEventListener('DOMContentLoaded', function() {
    const logoutLink = document.getElementById('logout-link');
    if (logoutLink) {
        logoutLink.addEventListener('click', function(e) {
            e.preventDefault();
            console.log('[reader-inspector] Logout clicked, available functions:', {
                hasConsultantLogout: typeof window.consultantLogout === 'function',
                hasLogout: typeof window.logout === 'function'
            });
            if (window.consultantLogout) {
                window.consultantLogout();
            } else if (window.logout) {
                window.logout();
            } else {
                // Fallback: direct logout
                console.log('[reader-inspector] Using fallback logout');
                sessionStorage.removeItem('auth_token');
                document.cookie = 'auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; SameSite=Lax';
                window.location.href = '/consultant/login';
            }
        });
    }
    
    loadConsultantUserInfo();
    loadReaderDetails();
    // Note: loadAIInteractions() and loadHelpRequests() are called from loadReaderDetails()
    // after bookId is determined, so we don't call them here
    
    // Start auto-refresh every 30 seconds
    startAutoRefresh();
});

// Start auto-refresh interval
function startAutoRefresh() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
    refreshInterval = setInterval(function() {
        refreshStats();
    }, 30000); // Refresh every 30 seconds
}

// Stop auto-refresh (e.g., when page is hidden)
function stopAutoRefresh() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
    }
}

// Pause auto-refresh when page is hidden, resume when visible
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        stopAutoRefresh();
    } else {
        startAutoRefresh();
        // Immediately refresh when page becomes visible
        refreshStats();
    }
});

// Refresh all data (stats and activities)
function refreshAll() {
    refreshStats();
    loadActivities();
    loadAIInteractions();
    loadHelpRequests();
}

// Load reading progress for the current reader
function loadReadingProgress(bookId) {
    const token = getAuthToken();
    if (!token || !readerId || !bookId) return;
    
    fetch(`/rest/v1/reading_progress?user_id=eq.${readerId}&book_id=eq.${bookId}`, {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(r => r.json())
    .then(readingProgress => {
        // Handle both array and single object responses
        const progress = Array.isArray(readingProgress) ? readingProgress[0] : readingProgress;
        const purchaseDateInput = document.getElementById('purchaseDateInput');
        const purchaseDateDisplay = document.getElementById('purchaseDateDisplay');
        
        if (progress && progress.purchase_date) {
            const date = new Date(progress.purchase_date);
            if (!isNaN(date.getTime())) {
                const formattedDate = date.toISOString().split('T')[0];
                purchaseDateInput.value = formattedDate;
                purchaseDateDisplay.textContent = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            }
        } else {
            purchaseDateInput.value = '';
            purchaseDateDisplay.textContent = 'Not set';
        }
    })
    .catch(err => {
        console.error('Error loading reading progress:', err);
    });
}

// Refresh only stats (for auto-refresh)
function refreshStats() {
    const token = getAuthToken();
    if (!token || !readerId) return;
    
    fetch(`/api/consultant/reader/activity?user_id=${readerId}&hours=720`, {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(r => r.json())
    .then(summary => {
        if (summary) {
            document.getElementById('totalActivities').textContent = summary.TotalActivities || 0;
            document.getElementById('activeDays').textContent = summary.ActiveDays || 0;
            document.getElementById('wordLookups').textContent = summary.WordLookups || 0;
            document.getElementById('pageViews').textContent = summary.PageViews || 0;
            
            // Update last updated timestamp
            const now = new Date();
            document.getElementById('lastUpdated').textContent = 
                `Last updated: ${now.toLocaleTimeString()}`;
        }
    })
    .catch(err => {
        console.error('Error refreshing stats:', err);
    });
}

// Load consultant user info
function loadConsultantUserInfo() {
    const token = getAuthToken();
    if (!token) return;
    
    fetch('/auth/v1/user', {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(res => res.json())
    .then(user => {
        const userNameDisplay = document.getElementById('user-name-display');
        const userNameBrand = document.getElementById('user-name-brand');
        const userInfoNav = document.getElementById('user-info-nav');
        
        if (userInfoNav) userInfoNav.style.display = 'block';
        
        let displayName = '';
        if (user.user_metadata) {
            const firstName = user.user_metadata.first_name || '';
            const lastName = user.user_metadata.last_name || '';
            displayName = firstName && lastName ? `${firstName} ${lastName}` : (firstName || user.email?.split('@')[0] || 'Consultant');
        } else if (user.first_name) {
            displayName = user.last_name ? `${user.first_name} ${user.last_name}` : user.first_name;
        } else if (user.email) {
            displayName = user.email.split('@')[0];
        } else {
            displayName = 'Consultant';
        }
        
        if (userNameDisplay) userNameDisplay.textContent = displayName;
        if (userNameBrand) {
            userNameBrand.textContent = displayName;
            userNameBrand.style.display = 'inline';
        }
    })
    .catch(err => console.error('Error loading user info:', err));
}

// Load reader details
function loadReaderDetails() {
    const token = getAuthToken();
    if (!token || !readerId) {
        document.getElementById('loadingState').innerHTML = '<p class="text-danger">Error: No authentication token or reader ID</p>';
        return;
    }
    
    // Get book_id from reader state first
    let bookId = null;
    fetch(`/api/consultant/reader/state?user_id=${readerId}`, {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(r => r.json())
    .then(state => {
        if (state && state.book_id) {
            bookId = state.book_id;
        } else {
            // If no book_id in state, get first book from system
            return fetch(`/rest/v1/books?limit=1`, {
                headers: {'Authorization': 'Bearer ' + token}
            }).then(r => r.json()).then(books => {
                if (Array.isArray(books) && books.length > 0) {
                    bookId = books[0].id;
                }
            });
        }
    })
    .then(() => {
        // Load reader info, activity summary, and reading progress in parallel
        const promises = [
            fetch(`/rest/v1/users?id=eq.${readerId}`, {
                headers: {'Authorization': 'Bearer ' + token}
            }).then(r => r.json()),
            fetch(`/api/consultant/reader/activity?user_id=${readerId}&hours=720`, {
                headers: {'Authorization': 'Bearer ' + token}
            }).then(r => r.json()),
            loadActivities()
        ];
        
        // Add reading progress fetch if we have a book_id
        if (bookId) {
            promises.push(
                fetch(`/rest/v1/reading_progress?user_id=eq.${readerId}&book_id=eq.${bookId}`, {
                    headers: {'Authorization': 'Bearer ' + token}
                }).then(r => r.json())
            );
        }
        
        return Promise.all(promises).then(results => {
            // Store bookId globally for other functions
            window.readerBookId = bookId;
            return results;
        });
    })
    .then((results) => {
        const users = results[0];
        const summary = results[1];
        const readingProgress = results.length > 3 ? results[3] : null;
        
        return [users, summary, readingProgress, bookId];
    })
    .then(([users, summary, readingProgress, currentBookId]) => {
        const reader = Array.isArray(users) && users.length > 0 ? users[0] : null;
        
        if (!reader) {
            document.getElementById('loadingState').innerHTML = '<p class="text-danger">Reader not found</p>';
            return;
        }
        
        // Store book_id globally for save function and other uses
        window.readerBookId = currentBookId;
        
        // Load AI interactions and help requests now that we have bookId
        if (currentBookId) {
            loadAIInteractions();
        }
        loadHelpRequests(); // Help requests don't require bookId
        
        // Set basic info
        const fullName = `${reader.first_name || ''} ${reader.last_name || ''}`.trim() || 'Unknown';
        document.getElementById('pageTitle').textContent = `Reader Inspector: ${fullName}`;
        document.getElementById('readerName').textContent = fullName;
        document.getElementById('readerEmail').textContent = reader.email || 'N/A';
        
        if (reader.created_at) {
            const createdDate = new Date(reader.created_at);
            document.getElementById('readerCreated').textContent = createdDate.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
        } else {
            document.getElementById('readerCreated').textContent = 'N/A';
        }
        
        document.getElementById('readerStatus').textContent = reader.is_verified ? '‚úì Verified' : 'Not Verified';
        
        // Set purchase date if available
        if (readingProgress) {
            // Handle both array and single object responses
            const progress = Array.isArray(readingProgress) ? readingProgress[0] : readingProgress;
            if (progress && progress.purchase_date) {
                const purchaseDateInput = document.getElementById('purchaseDateInput');
                const purchaseDateDisplay = document.getElementById('purchaseDateDisplay');
                // Format date for input (YYYY-MM-DD)
                const date = new Date(progress.purchase_date);
                if (!isNaN(date.getTime())) {
                    const formattedDate = date.toISOString().split('T')[0];
                    purchaseDateInput.value = formattedDate;
                    purchaseDateDisplay.textContent = date.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                }
            } else {
                // Clear if no purchase date
                document.getElementById('purchaseDateInput').value = '';
                document.getElementById('purchaseDateDisplay').textContent = 'Not set';
            }
        } else {
            // Clear if no reading progress
            document.getElementById('purchaseDateInput').value = '';
            document.getElementById('purchaseDateDisplay').textContent = 'Not set';
        }
        
        // Set activity summary
        if (summary) {
            document.getElementById('totalActivities').textContent = summary.TotalActivities || 0;
            document.getElementById('activeDays').textContent = summary.ActiveDays || 0;
            document.getElementById('wordLookups').textContent = summary.WordLookups || 0;
            document.getElementById('pageViews').textContent = summary.PageViews || 0;
        }
        
        // Update last updated timestamp
        const now = new Date();
        document.getElementById('lastUpdated').textContent = 
            `Last updated: ${now.toLocaleTimeString()}`;
        
        // Show content, hide loading
        document.getElementById('loadingState').style.display = 'none';
        document.getElementById('contentArea').style.display = 'block';
    })
    .catch(err => {
        console.error('Error loading reader details:', err);
        document.getElementById('loadingState').innerHTML = '<p class="text-danger">Error loading reader details. Please try again.</p>';
    });
}

// Load activities
function loadActivities() {
    const token = getAuthToken();
    if (!token || !readerId) return Promise.resolve();
    
    return Promise.all([
        fetch(`/rest/v1/interactions?user_id=eq.${readerId}&order=created_at.desc&limit=50`, {
            headers: {'Authorization': 'Bearer ' + token}
        }).then(r => r.json()),
        fetch(`/rest/v1/activity_logs?user_id=eq.${readerId}&order=created_at.desc&limit=50`, {
            headers: {'Authorization': 'Bearer ' + token}
        }).then(r => r.json())
    ])
    .then(([interactions, activityLogs]) => {
        // Combine and sort activities
        const allActivities = [];
        
        if (Array.isArray(interactions)) {
            interactions.forEach(activity => {
                // Parse context JSON if it exists
                let parsedContext = null;
                if (activity.context && typeof activity.context === 'string') {
                    try {
                        parsedContext = JSON.parse(activity.context);
                    } catch (e) {
                        console.warn('Failed to parse context JSON:', e);
                    }
                } else if (activity.context && typeof activity.context === 'object') {
                    parsedContext = activity.context;
                }
                
                allActivities.push({
                    ...activity,
                    source: 'interactions',
                    parsed_context: parsedContext,
                    created_at: activity.created_at
                });
            });
        }
        
        if (Array.isArray(activityLogs)) {
            activityLogs.forEach(activity => {
                // Parse metadata JSON if it exists (activity_logs uses metadata field)
                let parsedContext = null;
                if (activity.metadata && typeof activity.metadata === 'string') {
                    try {
                        parsedContext = JSON.parse(activity.metadata);
                    } catch (e) {
                        console.warn('Failed to parse metadata JSON:', e);
                    }
                } else if (activity.metadata && typeof activity.metadata === 'object') {
                    parsedContext = activity.metadata;
                }
                
                allActivities.push({
                    ...activity,
                    source: 'activity_logs',
                    event_type: activity.activity_type,
                    parsed_context: parsedContext,
                    created_at: activity.created_at
                });
            });
        }
        
        // Sort by date (most recent first)
        allActivities.sort((a, b) => {
            return new Date(b.created_at) - new Date(a.created_at);
        });
        
        // Display activities
        const activitiesContainer = document.getElementById('activitiesTimeline');
        if (allActivities.length === 0) {
            activitiesContainer.innerHTML = '<p class="text-muted">No activities found.</p>';
        } else {
            let activitiesHtml = '';
            allActivities.slice(0, 50).forEach(activity => {
                const date = new Date(activity.created_at);
                const timeStr = date.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                let activityDetail = '';
                if (activity.event_type === 'PAGE_SYNC' || activity.activity_type === 'PAGE_SYNC') {
                    let pageInfo = '';
                    if (activity.page_number) {
                        let sectionInfo = '';
                        if (activity.parsed_context && activity.parsed_context.section_index !== undefined) {
                            const sectionNum = typeof activity.parsed_context.section_index === 'number' 
                                ? activity.parsed_context.section_index 
                                : parseInt(activity.parsed_context.section_index, 10);
                            sectionInfo = ` - sect. ${sectionNum + 1}`;
                        }
                        pageInfo = `Page ${activity.page_number}${sectionInfo}`;
                    }
                    activityDetail = `Page Navigation: ${pageInfo || 'N/A'}`;
                } else if (activity.event_type === 'DEFINITION_LOOKUP' || activity.activity_type === 'WORD_LOOKUP') {
                    const word = activity.parsed_context?.word || activity.context?.word || 'word';
                    activityDetail = `Word Lookup: "${word}"`;
                } else if (activity.event_type === 'HELP_REQUEST' || activity.activity_type === 'HELP_REQUEST') {
                    activityDetail = `Help Request: ${activity.content ? activity.content.substring(0, 50) + '...' : 'Request made'}`;
                } else if (activity.event_type === 'LOGIN' || activity.activity_type === 'LOGIN') {
                    activityDetail = 'Logged In';
                } else if (activity.event_type === 'LOGOUT' || activity.activity_type === 'LOGOUT') {
                    activityDetail = 'Logged Out';
                } else {
                    activityDetail = activity.event_type || activity.activity_type || 'Activity';
                }
                
                activitiesHtml += `
                    <div class="activity-item">
                        <div class="activity-time">${timeStr}</div>
                        <div class="activity-detail">${escapeHtml(activityDetail)}</div>
                    </div>
                `;
            });
            activitiesContainer.innerHTML = activitiesHtml;
        }
    })
    .catch(err => {
        console.error('Error loading activities:', err);
        document.getElementById('activitiesTimeline').innerHTML = '<p class="text-danger">Error loading activities.</p>';
    });
}

// Save purchase date
function savePurchaseDate() {
    const token = getAuthToken();
    if (!token || !readerId) {
        alert('Error: No authentication token or reader ID');
        return;
    }
    
    const purchaseDateInput = document.getElementById('purchaseDateInput');
    const purchaseDate = purchaseDateInput.value; // Format: YYYY-MM-DD
    
    if (!window.readerBookId) {
        alert('Error: No book ID available. Please ensure the reader has a book assigned.');
        return;
    }
    
    fetch('/api/consultant/reader/purchase-date', {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
            user_id: readerId,
            book_id: window.readerBookId,
            purchase_date: purchaseDate || ''
        })
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success') {
            // Update display
            const purchaseDateInput = document.getElementById('purchaseDateInput');
            const purchaseDateDisplay = document.getElementById('purchaseDateDisplay');
            if (purchaseDate) {
                const date = new Date(purchaseDate);
                if (!isNaN(date.getTime())) {
                    purchaseDateInput.value = purchaseDate;
                    purchaseDateDisplay.textContent = date.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                }
            } else {
                purchaseDateInput.value = '';
                purchaseDateDisplay.textContent = 'Not set';
            }
            alert('Purchase date saved successfully!');
            // Reload the reading progress to ensure data is fresh
            if (window.readerBookId) {
                loadReadingProgress(window.readerBookId);
            }
        } else {
            alert('Error saving purchase date');
        }
    })
    .catch(err => {
        console.error('Error saving purchase date:', err);
        alert('Error saving purchase date. Please try again.');
    });
}

// Load AI Interactions
function loadAIInteractions() {
    const token = getAuthToken();
    if (!token || !readerId) {
        console.log('loadAIInteractions: Missing token or readerId', { token: !!token, readerId });
        return;
    }
    
    console.log('loadAIInteractions: Starting, readerId:', readerId);
    
    // Get book_id (we'll use the stored one or fetch first book)
    let bookId = window.readerBookId;
    if (!bookId) {
        console.log('loadAIInteractions: No bookId in window.readerBookId, fetching first book');
        // Try to get first book
        fetch(`/rest/v1/books?limit=1`, {
            headers: {'Authorization': 'Bearer ' + token}
        })
        .then(r => r.json())
        .then(books => {
            if (Array.isArray(books) && books.length > 0) {
                bookId = books[0].id;
                window.readerBookId = bookId;
                loadAIInteractionsWithBookId(bookId, token);
            } else {
                document.getElementById('aiInteractionsContainer').innerHTML = '<p class="text-muted">No book assigned to reader.</p>';
            }
        })
        .catch(err => {
            console.error('Error fetching books:', err);
            document.getElementById('aiInteractionsContainer').innerHTML = '<p class="text-danger">Error loading books.</p>';
        });
        return;
    }
    
    loadAIInteractionsWithBookId(bookId, token);
}

function loadAIInteractionsWithBookId(bookId, token) {
    console.log('loadAIInteractionsWithBookId: bookId:', bookId);
    
    const url = `/rest/v1/ai_interactions?user_id=eq.${readerId}&book_id=eq.${bookId}&order=created_at.desc&limit=50`;
    console.log('Fetching:', url);
    
    fetch(url, {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(r => {
        console.log('AI Interactions response status:', r.status);
        if (!r.ok) {
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        return r.json();
    })
    .then(interactions => {
        console.log('AI Interactions received:', interactions);
        const container = document.getElementById('aiInteractionsContainer');
        if (!container) {
            console.error('aiInteractionsContainer element not found!');
            return;
        }
        if (!Array.isArray(interactions) || interactions.length === 0) {
            container.innerHTML = '<p class="text-muted">No AI interactions found.</p>';
            return;
        }
        
        let html = '';
        interactions.forEach(interaction => {
            const date = new Date(interaction.created_at);
            const timeStr = date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // Get provider badge
            const provider = interaction.provider || 'unknown';
            let providerBadge = '';
            if (provider === 'gemini') {
                providerBadge = '<span class="badge bg-primary">Gemini</span>';
            } else if (provider === 'moonshot') {
                providerBadge = '<span class="badge bg-warning text-dark">Moonshot</span>';
            } else {
                providerBadge = '<span class="badge bg-secondary">Unknown</span>';
            }
            
            // Interaction type badge
            const interactionType = interaction.interaction_type || 'chat';
            const typeLabels = {
                'explain': 'Explain',
                'quiz': 'Quiz',
                'simplify': 'Simplify',
                'definition': 'Definition',
                'chat': 'Chat'
            };
            const typeLabel = typeLabels[interactionType] || interactionType;
            
            html += `
                <div class="card mb-3" style="border-left: 4px solid #007bff;">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <span class="badge bg-info me-2">${escapeHtml(typeLabel)}</span>
                            ${providerBadge}
                        </div>
                        <small class="text-muted">${timeStr}</small>
                    </div>
                    <div class="card-body">
                        <div class="mb-2">
                            <strong>Question:</strong>
                            <p class="mb-1" style="white-space: pre-wrap;">${escapeHtml(interaction.question || 'N/A')}</p>
                        </div>
                        <div>
                            <strong>AI Response:</strong>
                            <div class="mb-0 ai-response-content" style="background-color: #f8f9fa; padding: 0.75rem; border-radius: 4px; line-height: 1.6;">${formatAIResponse(interaction.response || 'N/A')}</div>
                        </div>
                    </div>
                </div>
            `;
        });
        container.innerHTML = html;
    })
    .catch(err => {
        console.error('Error loading AI interactions:', err);
        const container = document.getElementById('aiInteractionsContainer');
        if (container) {
            container.innerHTML = '<p class="text-danger">Error loading AI interactions: ' + escapeHtml(err.message) + '</p>';
        }
    });
}

// Load Help Requests
function loadHelpRequests() {
    const token = getAuthToken();
    if (!token || !readerId) {
        console.log('loadHelpRequests: Missing token or readerId', { token: !!token, readerId });
        return;
    }
    
    console.log('loadHelpRequests: Starting, readerId:', readerId);
    const url = `/rest/v1/help_requests?user_id=eq.${readerId}&order=created_at.desc&limit=50`;
    console.log('Fetching:', url);
    
    fetch(url, {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(r => {
        console.log('Help Requests response status:', r.status);
        if (!r.ok) {
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        return r.json();
    })
    .then(requests => {
        console.log('Help Requests received:', requests);
        const container = document.getElementById('helpRequestsContainer');
        if (!container) {
            console.error('helpRequestsContainer element not found!');
            return;
        }
        if (!Array.isArray(requests) || requests.length === 0) {
            container.innerHTML = '<p class="text-muted">No help requests found.</p>';
            return;
        }
        
        let html = '';
        requests.forEach(request => {
            const date = new Date(request.created_at);
            const timeStr = date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // Status badge
            const status = request.status || 'pending';
            let statusBadge = '';
            if (status === 'resolved') {
                statusBadge = '<span class="badge bg-success">Resolved</span>';
            } else if (status === 'assigned') {
                statusBadge = '<span class="badge bg-warning text-dark">Assigned</span>';
            } else {
                statusBadge = '<span class="badge bg-secondary">Pending</span>';
            }
            
            html += `
                <div class="card mb-3" style="border-left: 4px solid #28a745;">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            ${statusBadge}
                        </div>
                        <small class="text-muted">${timeStr}</small>
                    </div>
                    <div class="card-body">
                        <div class="mb-2">
                            <strong>Request:</strong>
                            <p class="mb-1" style="white-space: pre-wrap;">${escapeHtml(request.content || 'N/A')}</p>
                        </div>
                        ${request.context ? `
                        <div class="mb-2">
                            <strong>Context:</strong>
                            <p class="mb-1 text-muted small" style="white-space: pre-wrap;">${escapeHtml(request.context)}</p>
                        </div>
                        ` : ''}
                        ${request.response ? `
                        <div class="mt-2 pt-2 border-top">
                            <strong>Response:</strong>
                            <p class="mb-0" style="white-space: pre-wrap; background-color: #d4edda; padding: 0.75rem; border-radius: 4px;">${escapeHtml(request.response)}</p>
                        </div>
                        ` : ''}
                        ${request.resolved_at ? `
                        <div class="mt-2">
                            <small class="text-muted">Resolved: ${new Date(request.resolved_at).toLocaleString('en-US')}</small>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
        });
        container.innerHTML = html;
    })
    .catch(err => {
        console.error('Error loading help requests:', err);
        const container = document.getElementById('helpRequestsContainer');
        if (container) {
            container.innerHTML = '<p class="text-danger">Error loading help requests: ' + escapeHtml(err.message) + '</p>';
        }
    });
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Clean and format AI response text
function formatAIResponse(text) {
    if (!text) return '';
    
    // First, escape HTML to prevent XSS
    let formatted = escapeHtml(text);
    
    // Remove incomplete markdown at the end (like trailing *, **, ", etc.)
    formatted = formatted.trim();
    
    // Remove incomplete list items at the end (like "*   " or "-   ")
    formatted = formatted.replace(/[\*\-\+\d\.]\s*$/, '');
    
    // Remove trailing incomplete markdown patterns
    formatted = formatted.replace(/[\*"]+\s*$/, ''); // Remove trailing asterisks or quotes
    formatted = formatted.replace(/\s+$/, ''); // Remove trailing whitespace
    
    // Remove incomplete quote at end (if odd number of quotes, remove last one)
    const quoteCount = (formatted.match(/"/g) || []).length;
    if (quoteCount % 2 !== 0 && formatted.endsWith('"')) {
        formatted = formatted.slice(0, -1).trim();
    }
    
    // Fix incomplete markdown patterns - remove incomplete bold/italic
    // If response ends with ** or * and no matching close, remove it
    if (formatted.endsWith('**') && (formatted.match(/\*\*/g) || []).length % 2 !== 0) {
        formatted = formatted.slice(0, -2).trim();
    } else if (formatted.endsWith('*') && !formatted.endsWith('**')) {
        // Check if it's an incomplete italic marker
        const singleStars = formatted.match(/\*(?:\*\*)/g);
        const allStars = formatted.match(/\*/g) || [];
        if (allStars.length % 2 !== 0) {
            formatted = formatted.slice(0, -1).trim();
        }
    }
    
    // Now format markdown to HTML
    // Convert **bold** to <strong>bold</strong> (handle multiple per line)
    formatted = formatted.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
    
    // Convert *italic* to <em>italic</em> (but be careful not to match **bold**)
    // This regex matches *word* but not **word** by using negative lookahead/lookbehind
    formatted = formatted.replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, '<em>$1</em>');
    
    // Convert line breaks to <br> tags, but preserve double line breaks as paragraphs
    // Split by double line breaks first
    const paragraphs = formatted.split(/\n\n+/);
    formatted = paragraphs.map(para => {
        // Replace single line breaks with <br>
        para = para.replace(/\n/g, '<br>');
        // Wrap in <p> tags if there's content
        return para.trim() ? '<p>' + para.trim() + '</p>' : '';
    }).filter(p => p).join('');
    
    // If no paragraphs were created (no double line breaks), wrap the whole thing
    if (!formatted.includes('<p>')) {
        formatted = '<p>' + formatted + '</p>';
    }
    
    // Clean up any empty tags or double wrappings
    formatted = formatted.replace(/<p>\s*<\/p>/g, '');
    formatted = formatted.replace(/<p><p>/g, '<p>');
    formatted = formatted.replace(/<\/p><\/p>/g, '</p>');
    
    return formatted;
}
</script>
{{end}}


