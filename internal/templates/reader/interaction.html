{{define "title"}}Reading Interface - Alice Suite{{end}}

{{define "nav"}}
<li class="nav-item">
    <a class="nav-link active" href="/reader/interaction">Reading</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/reader/my-page">My Page</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="#" id="logout-link-reader">Logout</a>
</li>
{{end}}

{{define "head"}}
<style>
/* Section Snippets Styling */
.section-snippet {
    padding: 0.5rem;
    border-left: 3px solid #155724;
    background-color: #f8f9fa;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    -webkit-tap-highlight-color: transparent; /* Prevent tap highlight on mobile */
    touch-action: manipulation; /* Prevent double-tap zoom and improve touch response */
}

.section-snippet:hover {
    background-color: #d4edda;
    border-left-color: #1e7e34;
    transform: translateX(2px);
}

.section-snippet.active {
    background-color: #d4edda;
    border-left-color: #155724;
    border-left-width: 4px;
    font-weight: 500;
}

.snippet-text {
    color: #333;
    line-height: 1.4;
}

.section-content {
    transition: background-color 0.3s ease;
}

.section-content.section-highlight {
    background-color: #fff3cd;
    padding: 0.5rem;
    border-radius: 4px;
    animation: highlightFade 2s ease-out;
}

@keyframes highlightFade {
    0% {
        background-color: #fff3cd;
    }
    100% {
        background-color: transparent;
    }
}

#section-snippets {
    max-height: 600px;
    overflow-y: auto;
}

/* Collapsible Navigation Header */
.nav-collapse-header {
    cursor: pointer;
    user-select: none;
}

.nav-collapse-header:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

.nav-collapse-icon {
    float: right;
    transition: transform 0.3s ease;
}

.nav-collapse-header[aria-expanded="true"] .nav-collapse-icon {
    transform: rotate(180deg);
}

/* Prevent unwanted scrolling on mobile */
html {
    scroll-behavior: auto; /* Disable smooth scrolling that can cause jumps */
}

/* Prevent focus scrolling on mobile */
* {
    -webkit-overflow-scrolling: touch;
}

/* Prevent auto-scroll when content changes */
#page-content {
    scroll-behavior: auto;
}

/* Clickable word highlighting */
.word-highlight {
    cursor: pointer;
    color: #0056b3;
    text-decoration: underline;
    text-decoration-style: dotted;
    transition: background-color 0.2s ease;
}

.word-highlight:hover {
    background-color: #e7f3ff;
    border-radius: 2px;
}

/* Glossary terms - lighter blue to distinguish from regular vocabulary */
.word-highlight.glossary-term {
    color: #6BA3D6 !important; /* Light blue - lighter than regular vocabulary (#0056b3) */
    font-weight: 500;
    text-decoration-color: #6BA3D6 !important;
}

.word-highlight.glossary-term:hover {
    background-color: #E6F2FF !important; /* Light blue tint */
    color: #4A8BC2 !important; /* Slightly darker blue on hover */
}

/* Inline dictionary popup */
.dictionary-popup {
    position: fixed;
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 0;
    max-width: 350px;
    z-index: 1050;
    display: none;
    animation: popupFadeIn 0.2s ease-out;
    user-select: none; /* Prevent text selection during drag */
}

.dictionary-popup.show {
    display: block;
}

@keyframes popupFadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Draggable header area */
.dictionary-popup-drag-handle {
    cursor: move;
    padding: 0.75rem 1rem;
    background-color: #f8f9fa;
    border-bottom: 1px solid #ddd;
    border-radius: 8px 8px 0 0;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none; /* Prevent touch scrolling while dragging */
}

.dictionary-popup-drag-handle:active {
    cursor: grabbing;
    background-color: #e9ecef;
}

/* AI Help Modal - Draggable and smaller */
#aiHelpModalDialog {
    position: absolute !important;
}

#aiHelpModalDragHandle {
    cursor: move;
    user-select: none;
    -webkit-user-select: none;
}

#aiHelpModalDragHandle:active {
    cursor: grabbing;
}

/* AI Help Modal Resize Handle */
#aiHelpModalResizeHandle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 20px;
    height: 20px;
    cursor: nwse-resize;
    background: linear-gradient(135deg, transparent 0%, transparent 30%, #ccc 30%, #ccc 40%, transparent 40%, transparent 70%, #ccc 70%, #ccc 80%, transparent 80%);
    z-index: 1000;
    opacity: 0.6;
    transition: opacity 0.2s;
}

#aiHelpModalResizeHandle:hover {
    opacity: 1;
}

#aiHelpModalDialog {
    resize: none; /* Disable default browser resize, we'll use custom */
}

/* Transparent modal design - no chat box background */
#aiHelpModal .modal-content {
    background: transparent !important;
    border: 1px solid rgba(0, 0, 0, 0.15) !important;
    box-shadow: none !important;
    border-radius: 12px;
}

#aiHelpModal .modal-header {
    background: transparent !important;
    border: none !important;
    padding: 0.5rem 0 !important;
    margin-bottom: 0.5rem;
}

#aiHelpModal .modal-body {
    background: transparent !important;
}

#ai-chat-messages {
    background-color: transparent !important;
}

#ai-chat-empty-state {
    color: rgba(0, 0, 0, 0.5) !important;
}

/* WhatsApp-style Floating Chat Container */
.ai-chat-container {
    position: fixed;
    right: 20px;
    bottom: 80px;
    width: 380px;
    max-width: calc(100vw - 40px);
    height: 600px;
    max-height: calc(100vh - 100px);
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    z-index: 1050;
    transition: transform 0.3s ease, opacity 0.3s ease;
    overflow: hidden; /* Ensure resize handle stays in corner */
}

.ai-chat-container.dragging {
    transition: none;
}

.ai-chat-container.hidden {
    transform: translateY(20px);
    opacity: 0;
    pointer-events: none;
}

.ai-chat-header {
    background: #075E54;
    color: white;
    padding: 1rem;
    border-radius: 12px 12px 0 0;
    flex-shrink: 0;
    cursor: move;
    user-select: none;
}

.ai-chat-header.dragging {
    cursor: grabbing;
}

.ai-chat-avatar {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    background: transparent;
}

.ai-chat-avatar .ai-sparkle-svg {
    width: 100%;
    height: 100%;
}

.ai-chat-avatar .ai-sparkle-star {
    fill: #FFD700;
    stroke: none;
}

.ai-chat-avatar .ai-sparkle-star-small {
    fill: #FFC200;
    stroke: none;
}

.ai-chat-title {
    font-weight: 600;
    font-size: 0.95rem;
}

.ai-chat-subtitle {
    font-size: 0.75rem;
    opacity: 0.8;
}

.ai-chat-header-btn {
    background: none;
    border: none;
    color: white;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.25rem;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.8;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.ai-chat-header-btn:hover {
    opacity: 1;
    background: rgba(255,255,255,0.1);
}

.ai-chat-close-btn {
    background: none;
    border: none;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.8;
}

.ai-chat-close-btn:hover {
    opacity: 1;
}

/* Resize states */
.ai-chat-container.resized-small {
    width: 300px !important;
    height: 400px !important;
}

.ai-chat-container.resized-large {
    width: 500px !important;
    height: 700px !important;
}

/* Resize Handle */
.ai-chat-resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 20px;
    height: 20px;
    cursor: nwse-resize;
    background: linear-gradient(135deg, transparent 0%, transparent 30%, rgba(0,0,0,0.2) 30%, rgba(0,0,0,0.2) 40%, transparent 40%, transparent 70%, rgba(0,0,0,0.2) 70%, rgba(0,0,0,0.2) 80%, transparent 80%);
    z-index: 1051;
    opacity: 0.6;
    transition: opacity 0.2s ease;
    border-radius: 0 0 12px 0;
}

.ai-chat-resize-handle:hover {
    opacity: 1;
}

.ai-chat-container.resizing {
    transition: none !important;
}

.ai-chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    background: #ECE5DD;
    background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='chatPattern' x='0' y='0' width='100' height='100' patternUnits='userSpaceOnUse'%3E%3Ccircle cx='50' cy='50' r='1' fill='%23D4D4D4' opacity='0.3'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100' height='100' fill='url(%23chatPattern)'/%3E%3C/svg%3E");
}

.ai-chat-input-area {
    padding: 1rem;
    background: white;
    border-top: 1px solid #e0e0e0;
    flex-shrink: 0;
}

.ai-chat-input {
    border: 1px solid #e0e0e0 !important;
}

.ai-chat-send-btn {
    background: #25D366 !important;
    color: white;
}

.ai-chat-send-btn:hover {
    background: #20BA5A !important;
}

.ai-quick-action-btn {
    background: rgba(0,0,0,0.05);
    border: 1px solid rgba(0,0,0,0.1);
    color: #333;
    font-size: 0.8rem;
    padding: 0.25rem 0.75rem;
}

.ai-quick-action-btn:hover {
    background: rgba(0,0,0,0.1);
}

/* WhatsApp-style Chat Bubbles */
.chat-bubble.user {
    background-color: #DCF8C6;
    color: #000;
    border-bottom-right-radius: 4px;
    margin-left: auto;
}

.chat-bubble.ai {
    background-color: white;
    color: #000;
    border: 1px solid #e0e0e0;
    border-bottom-left-radius: 4px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* Minimized Chat Bar at Bottom - Right Side */
.ai-chat-minimized {
    position: fixed;
    bottom: 0;
    right: 20px;
    width: 380px;
    max-width: calc(100vw - 40px);
    background: white;
    border: 1px solid #e0e0e0;
    border-bottom: none;
    border-radius: 12px 12px 0 0;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    z-index: 1049;
    cursor: pointer;
    transition: transform 0.3s ease;
}

.ai-chat-minimized:hover {
    background: #f8f9fa;
}

.ai-chat-avatar-small {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    background: transparent;
}

.ai-chat-avatar-small .ai-sparkle-svg {
    width: 100%;
    height: 100%;
}

.ai-chat-avatar-small .ai-sparkle-star {
    fill: #FFD700;
    stroke: none;
}

.ai-chat-avatar-small .ai-sparkle-star-small {
    fill: #FFC200;
    stroke: none;
}

.ai-chat-title-small {
    font-weight: 600;
    font-size: 0.9rem;
    color: #333;
}

.ai-chat-last-message {
    font-size: 0.75rem;
    color: #666;
}

.ai-chat-close-btn-small {
    background: none;
    border: none;
    color: #999;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.25rem 0.5rem;
}

.ai-chat-close-btn-small:hover {
    color: #333;
}

.dictionary-popup-content-inner {
    padding: 1rem;
}

.dictionary-popup-header {
    font-weight: bold;
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
    color: #333;
    padding-bottom: 0.5rem;
}

.dictionary-popup-definition {
    color: #555;
    line-height: 1.5;
    margin-bottom: 0.5rem;
}

/* Glossary badge indicator */
.glossary-badge {
    margin-top: 0.25rem;
}

.glossary-badge .badge {
    font-size: 0.75rem;
    padding: 0.35rem 0.65rem;
    font-weight: 500;
    border-radius: 4px;
}

/* Examples container - hidden by default */
.dictionary-popup-examples-container {
    margin-top: 0.5rem;
    display: none; /* Hidden by default, shown when button is clicked */
}

.dictionary-popup-examples-container.show {
    display: block;
}

.dictionary-popup-example {
    color: #777;
    font-style: italic;
    font-size: 0.9rem;
    border-left: 3px solid #28a745;
    padding-left: 0.5rem;
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
}

.dictionary-popup-example:first-child {
    margin-top: 0;
}

.dictionary-popup-example:last-child {
    margin-bottom: 0;
}

/* Derivation container */
.dictionary-popup-derivation-container {
    margin-top: 0.5rem;
    display: none; /* Hidden by default, shown when button is clicked */
}

.dictionary-popup-derivation {
    color: #555;
    font-size: 0.9rem;
    line-height: 1.6;
    border-left: 3px solid #007bff;
    padding-left: 0.5rem;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    background-color: #f8f9fa;
    border-radius: 4px;
}

/* See example button */
.dictionary-popup-see-example {
    margin-top: 0.5rem;
    padding: 0.35rem 0.75rem;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-size: 0.85rem;
    color: #495057;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-block;
}

.dictionary-popup-see-example:hover {
    background-color: #e9ecef;
    border-color: #adb5bd;
}

.dictionary-popup-see-example:active {
    background-color: #dee2e6;
}

/* Additional examples (for when there are 2+ examples) */
.dictionary-popup-additional-examples {
    margin-top: 0.5rem;
    padding-top: 0.5rem;
    border-top: 1px solid #eee;
    display: none;
}

.dictionary-popup-additional-examples.show {
    display: block;
}

.dictionary-popup-additional-examples-title {
    display: block;
    color: #555;
    font-size: 0.85rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.dictionary-popup-additional-examples-list {
    margin: 0;
    padding-left: 1.25rem;
    list-style-type: disc;
}

.dictionary-popup-additional-examples-list li {
    color: #777;
    font-style: italic;
    font-size: 0.9rem;
    line-height: 1.5;
    margin-bottom: 0.4rem;
}

.dictionary-popup-additional-examples-list li:last-child {
    margin-bottom: 0;
}

/* Expand more examples button (if 3+ examples) */
.dictionary-popup-more-examples {
    margin-top: 0.5rem;
    padding: 0.25rem 0.5rem;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-size: 0.8rem;
    color: #495057;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-block;
}

.dictionary-popup-more-examples:hover {
    background-color: #e9ecef;
    border-color: #adb5bd;
}

.dictionary-popup-more-examples:active {
    background-color: #dee2e6;
}

.dictionary-popup-additional-examples-list {
    margin: 0.5rem 0 0 0;
    padding-left: 1.25rem;
    list-style-type: disc;
}

.dictionary-popup-additional-examples-list li {
    color: #777;
    font-style: italic;
    font-size: 0.9rem;
    line-height: 1.5;
    margin-bottom: 0.4rem;
}

.dictionary-popup-additional-examples-list li:last-child {
    margin-bottom: 0;
}

.dictionary-popup-close {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    color: #999;
    padding: 0;
    width: 24px;
    height: 24px;
    line-height: 1;
    flex-shrink: 0;
}

.dictionary-popup-close:hover {
    color: #333;
}

.dictionary-popup-close:active {
    color: #000;
}

/* Loading state */
.dictionary-popup-loading {
    text-align: center;
    color: #666;
    padding: 1rem;
}

/* AI Response Formatting */
.ai-response-formatted {
    line-height: 1.7;
    font-size: 0.95rem;
}

.ai-response-formatted p {
    margin-bottom: 1rem;
}

.ai-response-formatted p:last-child {
    margin-bottom: 0;
}

.ai-response-formatted strong {
    font-weight: 600;
    color: #0056b3;
}

.ai-response-formatted em {
    font-style: italic;
    color: #6c757d;
}

.ai-response-formatted br {
    line-height: 1.8;
}

/* Chat Interface Styles */
.chat-message {
    display: flex;
    margin-bottom: 1.5rem;
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.chat-message.user {
    justify-content: flex-end;
}

.chat-message.ai {
    justify-content: flex-start;
}

.chat-bubble {
    max-width: 85%;
    min-width: 120px;
    padding: 0.75rem 1rem;
    border-radius: 18px;
    word-wrap: break-word;
    line-height: 1.5;
    position: relative;
    width: auto;
    white-space: normal;
    overflow-wrap: break-word;
}

.chat-bubble.user {
    background-color: #007bff;
    color: white;
    border-bottom-right-radius: 4px;
}

.chat-bubble.ai {
    background-color: transparent;
    color: #333;
    border: none;
    border-bottom-left-radius: 4px;
    box-shadow: none;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.chat-message-header {
    font-size: 0.75rem;
    margin-bottom: 0.25rem;
    opacity: 0.8;
}

.chat-bubble.user .chat-message-header {
    color: rgba(255,255,255,0.9);
}

.chat-bubble.ai .chat-message-header {
    color: #6c757d;
}

.chat-message-content {
    font-size: 0.95rem;
}

.chat-bubble.user .chat-message-content {
    color: white;
}

.chat-message-time {
    font-size: 0.7rem;
    margin-top: 0.25rem;
    opacity: 0.6;
}

.chat-typing-indicator {
    display: flex;
    gap: 4px;
    padding: 0.5rem 0;
}

.chat-typing-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #999;
    animation: typing 1.4s infinite;
}

.chat-typing-dot:nth-child(2) {
    animation-delay: 0.2s;
}

.chat-typing-dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typing {
    0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.7;
    }
    30% {
        transform: translateY(-10px);
        opacity: 1;
    }
}

/* Text Selection Tool Styles */
.text-selection-active {
    position: relative;
    cursor: text;
    user-select: text;
    -webkit-user-select: text;
}

.text-selection-active * {
    user-select: text !important;
    -webkit-user-select: text !important;
    cursor: text !important;
}

/* When selection mode is active, allow text selection */
.text-selection-active .reading-content,
.text-selection-active .section-content,
.text-selection-active #ai-chat-messages {
    -webkit-touch-callout: default !important;
    touch-callout: default !important;
    -webkit-user-select: text !important;
    user-select: text !important;
}

.text-selection-active .reading-content *,
.text-selection-active .section-content *,
.text-selection-active #ai-chat-messages * {
    -webkit-touch-callout: default !important;
    touch-callout: default !important;
    -webkit-user-select: text !important;
    user-select: text !important;
    cursor: text !important;
}

.text-highlighted {
    background-color: #ffff00 !important;
    background-color: rgba(255, 255, 0, 0.7) !important;
    padding: 2px 0;
    border-radius: 2px;
    transition: background-color 0.2s ease;
    box-shadow: 0 1px 2px rgba(255, 255, 0, 0.3);
    /* Make it look like a real highlighter marker */
    -webkit-box-decoration-break: clone;
    box-decoration-break: clone;
}

.text-highlighted:hover {
    background-color: rgba(255, 255, 0, 0.85) !important;
}

/* Better selection styling - more visible when selection mode is active */
::selection {
    background-color: rgba(255, 255, 0, 0.7);
    color: inherit;
}

::-moz-selection {
    background-color: rgba(255, 255, 0, 0.7);
    color: inherit;
}

/* Enhanced selection visibility when selection mode is active */
.text-selection-active ::selection,
.text-selection-active ::-moz-selection {
    background-color: #ffeb3b !important;
    background-color: rgba(255, 235, 59, 0.9) !important;
    color: inherit;
}

/* Floating Selection Toolbar */
.selection-toolbar {
    position: fixed;
    background: transparent;
    border: none;
    padding: 0;
    z-index: 1060;
    display: none;
    gap: 0.35rem;
    align-items: center;
    animation: toolbarSlideIn 0.2s ease-out;
    cursor: move;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}

.selection-toolbar.dragging {
    cursor: grabbing;
}

.selection-toolbar.show {
    display: flex;
}

@keyframes toolbarSlideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* AI quick-action in selection toolbar */
.selection-ai-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    width: 44px;
    height: 44px;
    cursor: move;
    transition: all 0.2s ease;
    flex-shrink: 0;
    padding: 0;
    pointer-events: auto;
}

.selection-toolbar.dragging .selection-ai-btn {
    cursor: grabbing;
}

.selection-ai-btn:hover {
    transform: scale(1.15);
}

.selection-ai-btn:hover .ai-sparkle-svg {
    filter: drop-shadow(0 0 8px rgba(255, 200, 0, 0.8));
}

.ai-sparkle-svg {
    width: 40px;
    height: 40px;
    transition: filter 0.2s ease;
}

/* 4-pointed star sparkle shape */
.ai-sparkle-star {
    fill: url(#yellowGradient);
}

.ai-sparkle-star-small {
    fill: url(#yellowGradient);
}

.selection-ai-bubble {
    position: relative;
    background-color: white;
    color: #333;
    padding: 0.5rem 1.8rem 0.5rem 0.75rem;
    border-radius: 16px;
    border: 1px solid #e9ecef;
    box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    font-size: 0.85rem;
    white-space: nowrap;
    animation: bubbleSlideIn 0.3s ease-out;
    cursor: move;
    transition: background-color 0.2s ease;
    pointer-events: auto;
}

.selection-toolbar.dragging .selection-ai-bubble {
    cursor: grabbing;
}

.selection-ai-bubble:hover {
    background-color: #f8f9fa;
}

.selection-ai-bubble::before {
    content: '';
    position: absolute;
    top: 50%;
    left: -6px;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border: 6px solid transparent;
    border-right-color: white;
    border-left: 0;
}

.selection-ai-bubble::after {
    content: '';
    position: absolute;
    top: 50%;
    left: -8px;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border: 7px solid transparent;
    border-right-color: #e9ecef;
    border-left: 0;
    z-index: -1;
}

.selection-ai-close {
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #999;
    font-size: 0.75rem;
    cursor: pointer;
    padding: 2px 6px;
    border-radius: 50%;
    transition: all 0.2s ease;
    line-height: 1;
    pointer-events: auto;
    z-index: 10;
}

.selection-ai-close:hover {
    background-color: #eee;
    color: #666;
}

@keyframes bubbleSlideIn {
    from {
        opacity: 0;
        transform: translateX(-10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Selection mode indicator */
.selection-mode-indicator {
    position: fixed;
    top: 80px;
    right: 20px;
    background-color: #ffc107;
    color: #000;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    z-index: 1055;
    display: none;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    font-weight: 500;
    animation: indicatorPulse 2s infinite;
}

.selection-mode-indicator.active {
    display: flex;
}

@keyframes indicatorPulse {
    0%, 100% {
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    50% {
        box-shadow: 0 2px 12px rgba(255, 193, 7, 0.5);
    }
}

/* Mobile touch selection overlay */
.touch-selection-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1040;
    background: rgba(0, 0, 0, 0.02);
    display: none;
    touch-action: none;
}

.touch-selection-overlay.active {
    display: block;
}

/* Floating Pencil Button */
.pencil-select-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: 2px solid #007bff;
    background-color: white;
    color: #007bff;
    font-size: 1.2rem;
    cursor: move;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    z-index: 100;
    padding: 0;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}

.pencil-select-btn:hover {
    background-color: #007bff;
    color: white;
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0,123,255,0.3);
}

.pencil-select-btn:active {
    cursor: grabbing;
}

.pencil-select-btn.active {
    background-color: #007bff;
    color: white;
    border-color: #0056b3;
    box-shadow: 0 4px 12px rgba(0,123,255,0.4);
}

.pencil-select-btn.active:hover {
    background-color: #0056b3;
}

.pencil-select-btn.dragging {
    opacity: 0.8;
    cursor: grabbing;
    transform: scale(1.15);
    z-index: 101;
}

.pencil-select-btn.dragging:hover {
    transform: scale(1.15);
}

/* Ensure reading container is positioned relative for absolute button */
#reading-container {
    position: relative;
}

/* Improve text selection on mobile */
@media (max-width: 768px) {
    .reading-content {
        -webkit-tap-highlight-color: rgba(255, 255, 0, 0.3);
        -webkit-user-select: text;
        user-select: text;
        -webkit-touch-callout: default;
    }
    
    /* When selection mode is active, remove all restrictions */
    .text-selection-active {
        touch-action: auto !important;
    }
    
    .text-selection-active .reading-content,
    .text-selection-active .section-content,
    .text-selection-active #ai-chat-messages,
    .text-selection-active .reading-content *,
    .text-selection-active .section-content *,
    .text-selection-active #ai-chat-messages * {
        -webkit-user-select: text !important;
        user-select: text !important;
        -webkit-touch-callout: default !important;
        touch-callout: default !important;
        touch-action: auto !important;
        -webkit-tap-highlight-color: rgba(255, 255, 0, 0.3) !important;
        cursor: text !important;
        /* Increase line height for easier selection */
        line-height: 1.8 !important;
    }
    
    .pencil-select-btn {
        width: 40px;
        height: 40px;
        font-size: 1.3rem;
        /* Make it easier to tap on mobile */
        touch-action: none;
        -webkit-tap-highlight-color: rgba(0,123,255,0.2);
    }
    
    .selection-toolbar {
        left: auto !important;
        right: auto !important;
        max-width: calc(100vw - 20px);
    }
    
    .selection-ai-btn {
        width: 38px;
        height: 38px;
    }
    
    .ai-sparkle-svg {
        width: 34px;
        height: 34px;
    }
    
    .selection-ai-bubble {
        font-size: 0.8rem;
        padding: 0.4rem 1.6rem 0.4rem 0.6rem;
    }
    
    .selection-mode-indicator {
        top: 10px;
        right: 10px;
        left: 10px;
        justify-content: center;
    }
}
</style>
{{end}}

{{define "content"}}
<div class="row">
    <!-- Page Navigation (Sections) - First Column (Left) -->
    <div class="col-md-3">
        <div class="card">
            <div class="card-header nav-collapse-header" data-bs-toggle="collapse" data-bs-target="#navCollapseContent" aria-expanded="true" aria-controls="navCollapseContent">
                <h5 class="mb-0 d-inline">Page/Sections Navigation</h5>
                <span class="nav-collapse-icon">‚ñº</span>
            </div>
            <div class="collapse show" id="navCollapseContent">
                <div class="card-body">
                    <div class="mb-2 d-flex align-items-center justify-content-between gap-2">
                        <label for="page-number" class="form-label mb-0 small">Go to Page</label>
                        <input type="number" class="form-control form-control-sm" id="page-number" min="1" value="1" style="width: 80px;">
                        <button class="btn btn-sm btn-primary" onclick="event.preventDefault(); event.stopPropagation(); goToPage(); return false;">Go</button>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-sm btn-outline-primary flex-fill" onclick="event.preventDefault(); event.stopPropagation(); previousPage(); return false;">Previous</button>
                        <button class="btn btn-sm btn-outline-primary flex-fill" onclick="event.preventDefault(); event.stopPropagation(); nextPage(); return false;">Next</button>
                    </div>
                </div>
                <div class="card-body border-top">
                    <h6 class="mb-2">Select the section you're reading</h6>
                    <div id="section-snippets">
                        <p class="text-muted small">Loading sections...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Page Content (Book Text) - Second Column (Middle) -->
    <div class="col-md-6">
        <div class="card" id="reading-card">
            <div class="card-header">
                <h5 class="mb-0">Page <span id="current-page-display-main">1</span> - Section <span id="current-section">1</span></h5>
            </div>
            <div class="card-body" id="reading-container">
                <div id="page-content" class="reading-content">
                    <p class="text-muted">Loading page content...</p>
                </div>
                
            </div>
        </div>
    </div>

    <!-- Tools - Third Column (Right) -->
    <div class="col-md-3">
        <div class="card">
            <div class="card-header">
                <h5>Tools</h5>
            </div>
            <div class="card-body">
                <button class="btn btn-sm btn-outline-primary w-100 mb-2" onclick="showDictionary()">Dictionary</button>
                <button class="btn btn-sm btn-outline-primary w-100 mb-2" onclick="showAIHelp()">AI Help</button>
                <button class="btn btn-sm btn-outline-primary w-100" onclick="requestHelp()">Request Help</button>
            </div>
        </div>
    </div>
</div>

<!-- Selection Mode Indicator -->
<div class="selection-mode-indicator" id="selection-mode-indicator">
    <span>‚úèÔ∏è</span>
    <span>Selection Mode Active - Tap text to select</span>
</div>

<!-- Floating Selection Toolbar -->
<div class="selection-toolbar" id="selection-toolbar">
    <button class="selection-ai-btn" aria-label="Need AI assistance" title="Get AI help">
        <svg class="ai-sparkle-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="yellowGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#FFD700;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#FFC200;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#FFB000;stop-opacity:1" />
                </linearGradient>
            </defs>
            <!-- Large 4-pointed star -->
            <path class="ai-sparkle-star" d="M50 5 C52 35, 65 48, 95 50 C65 52, 52 65, 50 95 C48 65, 35 52, 5 50 C35 48, 48 35, 50 5 Z"/>
            <!-- Medium star (bottom left) -->
            <path class="ai-sparkle-star-small" d="M25 60 C26 72, 33 79, 45 80 C33 81, 26 88, 25 100 C24 88, 17 81, 5 80 C17 79, 24 72, 25 60 Z" transform="scale(0.5) translate(10, 90)"/>
            <!-- Small star (left) -->
            <path class="ai-sparkle-star-small" d="M15 45 C15.5 50, 18 52.5, 23 53 C18 53.5, 15.5 56, 15 61 C14.5 56, 12 53.5, 7 53 C12 52.5, 14.5 50, 15 45 Z"/>
        </svg>
    </button>
    <div class="selection-ai-bubble">
        Need AI assistance?
        <button class="selection-ai-close" aria-label="Close">‚úï</button>
    </div>
</div>

<!-- Touch Selection Overlay (for mobile) -->
<div class="touch-selection-overlay" id="touch-selection-overlay"></div>

<!-- Dictionary Modal (kept for manual lookup via Dictionary button) -->
<div class="modal fade" id="dictionaryModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Dictionary</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="lookup-word" class="form-label">Look up word</label>
                    <input type="text" class="form-control" id="lookup-word" placeholder="Enter word">
                </div>
                <button class="btn btn-primary" onclick="lookupWord()">Look Up</button>
                <div id="dictionary-result" class="mt-3"></div>
            </div>
        </div>
    </div>
</div>

<!-- WhatsApp-style Floating AI Chat -->
<div id="ai-chat-container" class="ai-chat-container" style="display: none;">
    <!-- Chat Header -->
    <div class="ai-chat-header" id="ai-chat-header">
        <div class="d-flex align-items-center justify-content-between">
            <div class="d-flex align-items-center gap-2">
                <span class="ai-chat-avatar">
                    <svg class="ai-sparkle-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="width: 40px; height: 40px;">
                        <!-- Large 4-pointed star -->
                        <path class="ai-sparkle-star" d="M50 5 C52 35, 65 48, 95 50 C65 52, 52 65, 50 95 C48 65, 35 52, 5 50 C35 48, 48 35, 50 5 Z"/>
                        <!-- Medium star (bottom left) -->
                        <path class="ai-sparkle-star-small" d="M25 60 C26 72, 33 79, 45 80 C33 81, 26 88, 25 100 C24 88, 17 81, 5 80 C17 79, 24 72, 25 60 Z" transform="scale(0.5) translate(10, 90)"/>
                        <!-- Small star (left) -->
                        <path class="ai-sparkle-star-small" d="M15 45 C15.5 50, 18 52.5, 23 53 C18 53.5, 15.5 56, 15 61 C14.5 56, 12 53.5, 7 53 C12 52.5, 14.5 50, 15 45 Z"/>
                    </svg>
                </span>
                <div>
                    <div class="ai-chat-title">AI Assistant</div>
                    <small class="ai-chat-subtitle">Online</small>
                </div>
            </div>
            <div class="d-flex align-items-center gap-1">
                <button class="ai-chat-header-btn" onclick="toggleAIChatResize()" title="Resize" id="ai-chat-resize-btn">‚§¢</button>
                <button class="ai-chat-header-btn" onclick="minimizeAIChatToBottom()" title="Minimize to bottom">‚àí</button>
                <button class="ai-chat-header-btn" onclick="closeAIChat()" title="Close">‚úï</button>
            </div>
        </div>
    </div>
    
    <!-- Chat Messages -->
    <div id="ai-chat-messages" class="ai-chat-messages">
        <div class="text-center text-muted py-5" id="ai-chat-empty-state">
            <p>Start a conversation with the AI assistant!</p>
            <small>Ask questions about what you're reading.</small>
        </div>
    </div>
    
    <!-- Resize Handle -->
    <div class="ai-chat-resize-handle" id="ai-chat-resize-handle" title="Drag to resize"></div>
    
    <!-- Chat Input Area -->
    <div class="ai-chat-input-area">
        <!-- Select Text Button -->
        <div class="mb-2">
            <button 
                class="btn btn-outline-primary btn-sm w-100" 
                id="ai-select-text-btn"
                onclick="activateTextSelectionMode()" 
                style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; background: rgba(255,255,255,0.95); border-color: rgba(0,123,255,0.3);">
                <span>‚úèÔ∏è</span>
                <span>Select the text you want to clarify</span>
            </button>
        </div>
        
        <div class="d-flex gap-2 align-items-end">
            <div class="flex-grow-1">
                <textarea 
                    class="form-control ai-chat-input" 
                    id="ai-question" 
                    rows="1" 
                    placeholder="Type a message..."
                    style="resize: none; max-height: 120px; background: white; border-radius: 20px; padding: 0.5rem 1rem;"
                    onkeydown="handleChatInputKeydown(event)"></textarea>
            </div>
            <button 
                class="btn ai-chat-send-btn" 
                onclick="askAI()" 
                id="ai-ask-button"
                style="height: 38px; width: 38px; border-radius: 50%; background: #25D366; border: none; padding: 0;">
                <span class="spinner-border spinner-border-sm d-none" id="ai-loading-spinner" role="status" style="width: 1rem; height: 1rem;"></span>
                <span id="ai-send-text">üì§</span>
            </button>
        </div>
        <div class="mt-2 d-flex gap-2 flex-wrap align-items-center">
            <button class="btn btn-sm ai-quick-action-btn" onclick="findMisunderstoodWordsWithAI()" title="Find the misunderstood word">Find the misunderstood word</button>
            <button class="btn btn-sm ai-quick-action-btn" onclick="setQuickQuestion('visual_example')" title="Get visual example">Visual</button>
            <button class="btn btn-sm ai-quick-action-btn" onclick="clearChat()" title="Clear conversation">Clear</button>
            <div id="ai-chat-selection-status" class="ms-auto text-success small fw-bold" style="display: none;">
                <span id="ai-chat-selection-status-text">Text selected - Press Enter</span>
            </div>
        </div>
    </div>
</div>

<!-- Minimized Chat Bar at Bottom -->
<div id="ai-chat-minimized" class="ai-chat-minimized" style="display: none;" onclick="expandAIChatFromBottom()">
    <div class="d-flex align-items-center justify-content-between p-2">
        <div class="d-flex align-items-center gap-2">
            <span class="ai-chat-avatar-small">
                <svg class="ai-sparkle-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="width: 32px; height: 32px;">
                    <!-- Large 4-pointed star -->
                    <path class="ai-sparkle-star" d="M50 5 C52 35, 65 48, 95 50 C65 52, 52 65, 50 95 C48 65, 35 52, 5 50 C35 48, 48 35, 50 5 Z"/>
                    <!-- Medium star (bottom left) -->
                    <path class="ai-sparkle-star-small" d="M25 60 C26 72, 33 79, 45 80 C33 81, 26 88, 25 100 C24 88, 17 81, 5 80 C17 79, 24 72, 25 60 Z" transform="scale(0.5) translate(10, 90)"/>
                    <!-- Small star (left) -->
                    <path class="ai-sparkle-star-small" d="M15 45 C15.5 50, 18 52.5, 23 53 C18 53.5, 15.5 56, 15 61 C14.5 56, 12 53.5, 7 53 C12 52.5, 14.5 50, 15 45 Z"/>
                </svg>
            </span>
            <div>
                <div class="ai-chat-title-small">AI Assistant</div>
                <small class="ai-chat-last-message" id="ai-chat-last-message-preview">Tap to open chat</small>
            </div>
        </div>
        <button class="ai-chat-close-btn-small" onclick="event.stopPropagation(); closeAIChat();" title="Close">‚úï</button>
    </div>
</div>

<!-- Inline Dictionary Popup (Tier 1: Instant definitions) -->
<div id="dictionary-popup" class="dictionary-popup">
    <div class="dictionary-popup-drag-handle" id="dictionary-popup-drag-handle">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: 500; color: #666; font-size: 0.9rem;">Dictionary</span>
            <button class="dictionary-popup-close" onclick="event.stopPropagation(); hideDictionaryPopup(); return false;" aria-label="Close" style="position: relative; top: 0; right: 0; background: none; border: none; font-size: 1.2rem; cursor: pointer; color: #999; padding: 0; width: 24px; height: 24px; line-height: 1;">&times;</button>
        </div>
    </div>
    <div class="dictionary-popup-content-inner" id="dictionary-popup-content">
        <div class="dictionary-popup-loading">Loading definition...</div>
    </div>
</div>
{{end}}

{{define "scripts"}}
<script>
console.log('[interaction.html] ========== SCRIPT BLOCK LOADING ==========');
let currentPage = 1;
const bookId = 'alice-in-wonderland'; // Default book ID
console.log('[interaction.html] Variables initialized, bookId:', bookId);

// Store all glossary terms for highlighting
let glossaryTerms = new Set(); // Set of lowercase terms for fast lookup
let glossaryTermsMap = new Map(); // Map of lowercase term -> original term object
let glossaryTermsList = []; // Array of all terms sorted by length (longest first) for multi-word matching
let currentPageSections = []; // Store sections for current page
let currentSectionIndex = 0; // Track current section index (0-based)

// Load all glossary terms for highlighting
function loadGlossaryTerms() {
    return new Promise((resolve, reject) => {
        console.log('[loadGlossaryTerms] Starting to load glossary terms...');
        const token = getAuthToken();
        if (!token) {
            console.warn('[loadGlossaryTerms] No auth token, skipping glossary load');
            resolve(); // Resolve without error if no token
            return;
        }
        
        const url = `/rest/v1/alice_glossary?book_id=${bookId}`;
        console.log('[loadGlossaryTerms] Fetching from:', url);
        
        fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token
            }
        })
        .then(res => {
            console.log('[loadGlossaryTerms] Response status:', res.status, res.statusText);
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            return res.json();
        })
        .then(terms => {
            console.log('[loadGlossaryTerms] Received response:', terms);
            console.log('[loadGlossaryTerms] Is array?', Array.isArray(terms));
            console.log('[loadGlossaryTerms] Terms count:', Array.isArray(terms) ? terms.length : 'not an array');
            
            if (Array.isArray(terms)) {
                glossaryTerms.clear();
                glossaryTermsMap.clear();
                glossaryTermsList = [];
                
                terms.forEach(term => {
                    if (term && term.term) {
                        const normalizedTerm = term.term.toLowerCase().trim();
                        glossaryTerms.add(normalizedTerm);
                        glossaryTermsMap.set(normalizedTerm, term);
                        glossaryTermsList.push(normalizedTerm);
                    }
                });
                
                // Sort by length (longest first) to match multi-word terms first
                glossaryTermsList.sort((a, b) => b.length - a.length);
                
                console.log(`[loadGlossaryTerms] ‚úÖ Loaded ${glossaryTerms.size} glossary terms for highlighting`);
                console.log(`[loadGlossaryTerms] Sample glossary terms:`, Array.from(glossaryTerms).slice(0, 10));
                resolve();
            } else {
                console.warn('[loadGlossaryTerms] Response is not an array:', typeof terms, terms);
                resolve(); // Resolve even if no terms
            }
        })
        .catch(err => {
            console.error('[loadGlossaryTerms] ‚ùå Error loading glossary terms:', err);
            console.error('[loadGlossaryTerms] Error details:', err.message, err.stack);
            resolve(); // Resolve even on error to not block page loading
        });
    });
}

function loadPage(pageNumber) {
    const token = getAuthToken();
    if (!token) {
        window.location.href = '/login';
        return;
    }

    document.getElementById('page-content').innerHTML = '<p class="text-muted">Loading...</p>';
    document.getElementById('section-snippets').innerHTML = '<p class="text-muted small">Loading sections...</p>';

    fetch(`/rest/v1/rpc/get_sections_for_page`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
            book_id: bookId,
            page_number: pageNumber
        })
    })
    .then(async res => {
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`HTTP ${res.status}: ${errorText}`);
        }
        return res.json();
    })
    .then(page => {
        // Log with alert to ensure visibility
        console.log('[loadPage] Received page data:', JSON.stringify(page, null, 2));
        console.log('[loadPage] Page keys:', Object.keys(page || {}));
        console.log('[loadPage] page.sections:', page?.sections);
        console.log('[loadPage] page.sections length:', page?.sections?.length);
        console.log('[loadPage] page.content:', page?.content ? 'exists (' + page.content.length + ' chars)' : 'not present');
        
        // Handle Page object with sections array
        if (!page) {
            console.error('[loadPage] Page data is null or undefined');
            document.getElementById('page-content').innerHTML = '<p class="text-muted">No content found for this page.</p>';
            document.getElementById('section-snippets').innerHTML = '<p class="text-muted small">No sections available.</p>';
            currentPageSections = [];
            return;
        }

        // Check for sections array (new structure)
        let sections = page.sections;
        console.log('[loadPage] Initial sections check:', sections);
        
        if (!sections || !Array.isArray(sections) || sections.length === 0) {
            console.log('[loadPage] Sections array is empty or invalid, checking for content field');
            // Fallback: check if there's a content field (old structure)
            if (page.content && page.content.trim()) {
                console.log('[loadPage] Using old structure with content field');
                // Create a single section from the content
                sections = [{
                    id: page.id || 'section-1',
                    content: page.content,
                    page_number: page.page_number || pageNumber,
                    section_number: 1
                }];
            } else {
                console.error('[loadPage] No sections or content found in page data');
                console.error('[loadPage] Page object:', page);
                document.getElementById('page-content').innerHTML = '<p class="text-muted">No content found for this page.</p>';
                document.getElementById('section-snippets').innerHTML = '<p class="text-muted small">No sections available.</p>';
                currentPageSections = [];
                return;
            }
        }

        console.log('[loadPage] Final sections array length:', sections.length);
        console.log('[loadPage] Sections details:', sections.map((s, i) => ({
            index: i,
            id: s.id,
            contentLength: s.content ? s.content.length : 0,
            hasContent: !!s.content
        })));

        // Store sections data
        currentPageSections = sections;
        console.log('[loadPage] Stored', currentPageSections.length, 'sections in currentPageSections');

        // Build section snippets for middle column
        let snippetsHtml = '';
        let snippetCount = 0;
        let totalContentLength = 0;
        sections.forEach((section, index) => {
            const sectionContent = section.content || '';
            totalContentLength += sectionContent.length;
            console.log(`[loadPage] Processing section ${index}, content length: ${sectionContent.length}`);
            
            // Warn if a section seems unusually long (might be full page content)
            if (sectionContent.length > 5000) {
                console.warn(`[loadPage] WARNING: Section ${index} content is very long (${sectionContent.length} chars), might be full page`);
            }
            
            if (sectionContent && sectionContent.trim()) {
                const snippet = getFirstWords(sectionContent, 6);
                snippetsHtml += `
                    <div class="section-snippet mb-2" data-section-index="${index}" onclick="event.preventDefault(); event.stopPropagation(); showSection(${index}); return false;">
                        <div class="snippet-text small">${escapeHtml(snippet)}...</div>
                    </div>
                `;
                snippetCount++;
                console.log(`[loadPage] Added snippet ${index}: "${snippet}"...`);
            } else {
                console.warn(`[loadPage] Section ${index} has no content, skipping snippet`);
            }
        });
        
        console.log('[loadPage] Total content length across all sections:', totalContentLength);
        console.log('[loadPage] Average section length:', sections.length > 0 ? totalContentLength / sections.length : 0);

        console.log('[loadPage] Built', snippetCount, 'snippets, HTML length:', snippetsHtml.length);
        document.getElementById('section-snippets').innerHTML = snippetsHtml || '<p class="text-muted small">No snippets available.</p>';

        // Verify snippets were added
        const snippetElements = document.querySelectorAll('.section-snippet');
        console.log('[loadPage] Actual snippet elements in DOM:', snippetElements.length);
        
        if (snippetElements.length !== snippetCount) {
            console.error('[loadPage] MISMATCH: Expected', snippetCount, 'snippets but found', snippetElements.length, 'in DOM');
            if (debugText) {
                debugText.textContent += ` (WARNING: ${snippetElements.length} in DOM)`;
                debugText.style.color = 'red';
            }
        }

        // Show first section by default
        if (sections.length > 0 && sections[0].content) {
            currentSectionIndex = 0;
            console.log('[loadPage] About to call showSection(0)');
            console.log('[loadPage] First section content preview:', sections[0].content.substring(0, 100) + '...');
            showSection(0);
        } else {
            console.error('[loadPage] Cannot show first section - no sections or first section has no content');
        }

        document.getElementById('current-page-display-main').textContent = pageNumber;
        currentPage = pageNumber;

        // Track page navigation with section information
        trackActivity('PAGE_SYNC', { 
            page_number: pageNumber,
            section_index: currentSectionIndex
        });
    })
    .catch(err => {
        console.error('Error loading page:', err);
        document.getElementById('page-content').innerHTML = '<p class="text-danger">Error loading page content: ' + err.message + '</p>';
    });
}

function formatTextWithWordHighlights(text) {
    // Make all words clickable for Tier 1 instant definitions
    // Highlight glossary terms with a different color
    // Handles punctuation and preserves original formatting
    if (!text) return '';
    
    // Split by whitespace and process each word
    const words = text.split(/(\s+)/); // Split but keep whitespace
    return words.map((part, index) => {
        // Skip whitespace parts
        if (/^\s+$/.test(part)) {
            return part;
        }
        
        // Extract word without punctuation for lookup, but keep punctuation in display
        const cleanWord = part.replace(/[.,!?;:()\[\]{}"']/g, '').toLowerCase();
        
        // Skip empty strings (just punctuation)
        if (!cleanWord) {
            return escapeHtml(part);
        }
        
        // Escape HTML for security and create clickable word
        const escapedWord = escapeHtml(part);
        const escapedCleanWord = escapeHtml(cleanWord);
        
        // Check if this word is in the glossary
        const isGlossaryTerm = glossaryTerms.has(cleanWord);
        const cssClass = isGlossaryTerm ? 'word-highlight glossary-term' : 'word-highlight';
        
        // Create clickable span with word
        return `<span class="${cssClass}" onclick="lookupWordFromText('${escapedCleanWord}', event)" data-word="${escapedCleanWord}">${escapedWord}</span>`;
    }).join('');
}

function getFirstWords(text, numWords) {
    if (!text) return '';
    // Remove HTML tags if any, then split by whitespace
    const plainText = text.replace(/<[^>]*>/g, '');
    const words = plainText.trim().split(/\s+/);
    return words.slice(0, numWords).join(' ');
}

function showSection(sectionIndex) {
    console.log('========== [showSection] START ==========');
    console.log('[showSection] Called with index:', sectionIndex);
    console.log('[showSection] currentPageSections:', currentPageSections);
    console.log('[showSection] currentPageSections length:', currentPageSections ? currentPageSections.length : 0);
    console.log('[showSection] currentPage:', currentPage);
    
    // Validate section index
    if (!currentPageSections || currentPageSections.length === 0) {
        console.error('[showSection] ERROR: No sections available in currentPageSections');
        alert('ERROR: No sections available. Check console for details.');
        return;
    }
    
    if (sectionIndex < 0 || sectionIndex >= currentPageSections.length) {
        console.error('[showSection] ERROR: Invalid section index:', sectionIndex, 'out of range [0,', currentPageSections.length, ')');
        alert('ERROR: Invalid section index: ' + sectionIndex);
        return;
    }

    // Preserve scroll position to prevent jumping on mobile
    const scrollPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;

    // Update current section index
    currentSectionIndex = sectionIndex;
    console.log('[showSection] Set currentSectionIndex to:', currentSectionIndex);

    // Get the selected section
    const section = currentPageSections[sectionIndex];
    console.log('[showSection] Selected section object:', section);
    console.log('[showSection] Section keys:', section ? Object.keys(section) : 'null');
    console.log('[showSection] Section has content field:', section ? 'content' in section : false);
    console.log('[showSection] Section content type:', typeof (section?.content));
    console.log('[showSection] Section content length:', section?.content ? section.content.length : 0);

    if (!section) {
        console.error('[showSection] ERROR: Section is null or undefined');
        alert('ERROR: Section is null');
        return;
    }

    // Update active snippet
    const allSnippets = document.querySelectorAll('.section-snippet');
    console.log('[showSection] Found', allSnippets.length, 'snippet elements in DOM');
    allSnippets.forEach((snippet, idx) => {
        snippet.classList.remove('active');
        console.log('[showSection] Removed active from snippet', idx);
    });
    
    const snippetElement = document.querySelector(`[data-section-index="${sectionIndex}"]`);
    console.log('[showSection] Looking for snippet with data-section-index="', sectionIndex, '", found:', !!snippetElement);
    
    if (snippetElement) {
        snippetElement.classList.add('active');
        console.log('[showSection] Activated snippet element');
    } else {
        console.warn('[showSection] WARNING: Snippet element not found for index:', sectionIndex);
        console.warn('[showSection] Available snippet indices:', Array.from(allSnippets).map(s => s.getAttribute('data-section-index')));
    }

    // Get section content
    const sectionContent = section.content || '';
    console.log('[showSection] Extracted sectionContent, length:', sectionContent.length);
    console.log('[showSection] Section content preview (first 200 chars):', sectionContent.substring(0, 200));
    
    if (!sectionContent || !sectionContent.trim()) {
        console.error('[showSection] ERROR: Section content is empty');
        alert('ERROR: Section content is empty');
        document.getElementById('page-content').innerHTML = '<p class="text-muted">No content available for this section.</p>';
        return;
    }

    // Display only the selected section in the content area
    console.log('[showSection] Glossary terms loaded:', glossaryTerms.size);
    const formattedContent = formatTextWithWordHighlights(sectionContent);
    console.log('[showSection] Formatted content length:', formattedContent.length);
    console.log('[showSection] Formatted content preview (first 200 chars):', formattedContent.substring(0, 200));
    
    // Count how many glossary terms were found in this section
    const glossaryTermMatches = formattedContent.match(/glossary-term/g);
    const glossaryTermCount = glossaryTermMatches ? glossaryTermMatches.length : 0;
    console.log('[showSection] Found', glossaryTermCount, 'glossary term highlights in formatted content');
    
    const content = `<div class="section-content">${formattedContent}</div>`;
    const pageContentElement = document.getElementById('page-content');
    
    if (pageContentElement) {
        const previousContent = pageContentElement.innerHTML;
        console.log('[showSection] Previous content length:', previousContent.length);
        pageContentElement.innerHTML = content;
        console.log('[showSection] Updated page content with section', sectionIndex);
        console.log('[showSection] New content length:', pageContentElement.innerHTML.length);
        
        // Restore scroll position to prevent jumping on mobile
        // Use requestAnimationFrame to ensure DOM has updated
        requestAnimationFrame(() => {
            window.scrollTo(0, scrollPosition);
        });
    } else {
        console.error('[showSection] ERROR: Page content element not found');
        alert('ERROR: Page content element not found');
        return;
    }
    
    // Update current section number display (1-based for user display)
    const currentSectionElement = document.getElementById('current-section');
    if (currentSectionElement) {
        currentSectionElement.textContent = sectionIndex + 1;
    }

    // Track section navigation
    trackActivity('PAGE_SYNC', { 
        page_number: currentPage,
        section_index: sectionIndex
    });
    
    console.log('========== [showSection] END ==========');
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Clean and format AI response text
function formatAIResponse(text) {
    if (!text) return '';
    
    // First, escape HTML to prevent XSS
    let formatted = escapeHtml(text);
    
    // Remove incomplete markdown at the end (like trailing *, **, ", etc.)
    formatted = formatted.trim();
    
    // Remove trailing incomplete markdown patterns
    formatted = formatted.replace(/[\*"]+\s*$/, ''); // Remove trailing asterisks or quotes
    formatted = formatted.replace(/\s+$/, ''); // Remove trailing whitespace
    
    // Remove incomplete list items at the end (like "*   " or "-   ")
    formatted = formatted.replace(/[\*\-\+\d\.]\s*$/, '');
    
    // Fix incomplete markdown patterns - remove incomplete bold/italic
    // If response ends with ** or * and no matching close, remove it
    if (formatted.endsWith('**') && (formatted.match(/\*\*/g) || []).length % 2 !== 0) {
        formatted = formatted.slice(0, -2).trim();
    } else if (formatted.endsWith('*') && !formatted.endsWith('**')) {
        // Check if it's an incomplete italic marker
        const allStars = formatted.match(/\*/g) || [];
        if (allStars.length % 2 !== 0) {
            formatted = formatted.slice(0, -1).trim();
        }
    }
    
    // Remove incomplete quote at end (if odd number of quotes, remove last one)
    const quoteCount = (formatted.match(/"/g) || []).length;
    if (quoteCount % 2 !== 0 && formatted.endsWith('"')) {
        formatted = formatted.slice(0, -1).trim();
    }
    
    // Now format markdown to HTML
    // Convert **bold** to <strong>bold</strong> (handle multiple per line)
    formatted = formatted.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
    
    // Convert *italic* to <em>italic</em> (but be careful not to match **bold**)
    // This regex matches *word* but not **word** by using negative lookahead/lookbehind
    formatted = formatted.replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, '<em>$1</em>');
    
    // Convert line breaks to <br> tags, but preserve double line breaks as paragraphs
    // Split by double line breaks first
    const paragraphs = formatted.split(/\n\n+/);
    formatted = paragraphs.map(para => {
        // Replace single line breaks with <br>
        para = para.replace(/\n/g, '<br>');
        // Wrap in <p> tags if there's content
        return para.trim() ? '<p>' + para.trim() + '</p>' : '';
    }).filter(p => p).join('');
    
    // If no paragraphs were created (no double line breaks), wrap the whole thing
    if (!formatted.includes('<p>')) {
        formatted = '<p>' + formatted + '</p>';
    }
    
    // Clean up any empty tags or double wrappings
    formatted = formatted.replace(/<p>\s*<\/p>/g, '');
    formatted = formatted.replace(/<p><p>/g, '<p>');
    formatted = formatted.replace(/<\/p><\/p>/g, '</p>');
    
    return formatted;
}

// Drag state for dictionary popup
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let popupStartX = 0;
let popupStartY = 0;

// Initialize drag functionality for dictionary popup
function initDictionaryPopupDrag() {
    const popup = document.getElementById('dictionary-popup');
    const dragHandle = document.getElementById('dictionary-popup-drag-handle');
    
    if (!popup || !dragHandle) return;
    
    // Mouse events
    dragHandle.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
    
    // Touch events for mobile
    dragHandle.addEventListener('touchstart', startDragTouch, { passive: false });
    document.addEventListener('touchmove', dragTouch, { passive: false });
    document.addEventListener('touchend', stopDrag);
    
    function startDrag(e) {
        if (e.target.classList.contains('dictionary-popup-close')) {
            return; // Don't start drag if clicking close button
        }
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        const rect = popup.getBoundingClientRect();
        popupStartX = rect.left;
        popupStartY = rect.top;
        popup.style.cursor = 'grabbing';
        e.preventDefault();
    }
    
    function startDragTouch(e) {
        if (e.target.classList.contains('dictionary-popup-close')) {
            return;
        }
        const touch = e.touches[0];
        isDragging = true;
        dragStartX = touch.clientX;
        dragStartY = touch.clientY;
        const rect = popup.getBoundingClientRect();
        popupStartX = rect.left;
        popupStartY = rect.top;
        e.preventDefault();
    }
    
    function drag(e) {
        if (!isDragging) return;
        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;
        popup.style.left = (popupStartX + deltaX) + 'px';
        popup.style.top = (popupStartY + deltaY) + 'px';
        popup.style.transform = 'none'; // Remove centering transform
        e.preventDefault();
    }
    
    function dragTouch(e) {
        if (!isDragging) return;
        const touch = e.touches[0];
        const deltaX = touch.clientX - dragStartX;
        const deltaY = touch.clientY - dragStartY;
        popup.style.left = (popupStartX + deltaX) + 'px';
        popup.style.top = (popupStartY + deltaY) + 'px';
        popup.style.transform = 'none';
        e.preventDefault();
    }
    
    function stopDrag() {
        if (isDragging) {
            isDragging = false;
            popup.style.cursor = '';
        }
    }
}

// Show inline dictionary popup (Tier 1: Instant definitions)
function lookupWordFromText(word, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    
    if (!word || !word.trim()) return;
    
    const popup = document.getElementById('dictionary-popup');
    const popupContent = document.getElementById('dictionary-popup-content');
    
    if (!popup || !popupContent) return;
    
    // Initialize drag functionality if not already done
    if (!popup.dataset.dragInitialized) {
        initDictionaryPopupDrag();
        popup.dataset.dragInitialized = 'true';
    }
    
    // Show popup with loading state
    popupContent.innerHTML = '<div class="dictionary-popup-loading">Loading definition...</div>';
    popup.classList.add('show');
    
    // Position popup near the clicked word
    if (event && event.target) {
        const rect = event.target.getBoundingClientRect();
        popup.style.left = rect.left + 'px';
        popup.style.top = (rect.bottom + 5) + 'px';
        popup.style.transform = 'none';
        
        // Adjust if popup goes off-screen
        setTimeout(() => {
            const popupRect = popup.getBoundingClientRect();
            if (popupRect.right > window.innerWidth) {
                popup.style.left = (window.innerWidth - popupRect.width - 10) + 'px';
            }
            if (popupRect.bottom > window.innerHeight) {
                popup.style.top = (rect.top - popupRect.height - 5) + 'px';
            }
            if (popupRect.top < 0) {
                popup.style.top = '10px';
            }
            if (popupRect.left < 0) {
                popup.style.left = '10px';
            }
        }, 0);
    } else {
        // Center popup if no event position
        popup.style.left = '50%';
        popup.style.top = '50%';
        popup.style.transform = 'translate(-50%, -50%)';
    }
    
    // Fetch definition
    lookupWordInline(word, popupContent);
}

// Hide inline dictionary popup
function hideDictionaryPopup() {
    const popup = document.getElementById('dictionary-popup');
    if (popup) {
        popup.classList.remove('show');
        // Reset drag state
        isDragging = false;
        popup.style.cursor = '';
    }
}

// Lookup word and display in inline popup
function lookupWordInline(word, popupContent) {
    // Normalize word the same way as formatTextWithWordHighlights and backend DictionaryService
    // Remove punctuation and convert to lowercase (matching backend NormalizeWord function)
    let wordToLookup = word.trim();
    if (wordToLookup) {
        // Remove punctuation (keep hyphens and apostrophes for compound words - matching backend regex [^\w'-])
        // But for simplicity, remove all punctuation like formatTextWithWordHighlights does
        wordToLookup = wordToLookup.replace(/[.,!?;:()\[\]{}"']/g, '').toLowerCase();
    }
    
    if (!wordToLookup) {
        popupContent.innerHTML = '<div class="dictionary-popup-loading text-danger">No word provided</div>';
        return;
    }
    
    const token = getAuthToken();
    fetch('/rest/v1/rpc/get_definition_with_context', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
            term: wordToLookup,
            book_id: bookId
        })
    })
    .then(res => {
        // Check if response is OK
        if (!res.ok) {
            console.error('Dictionary API error:', res.status, res.statusText);
            popupContent.innerHTML = `<div class="dictionary-popup-loading text-danger">API Error: ${res.status} ${res.statusText}. Please check server logs.</div>`;
            return null;
        }
        return res.json();
    })
    .then(data => {
        if (!data) return; // Error already handled
        
        console.log('Dictionary lookup response:', data); // Debug log
        
        if (data.definition && data.definition !== 'Word not found in dictionary.') {
            let html = `<div class="dictionary-popup-header">${escapeHtml(data.term || wordToLookup)}</div>`;
            
            // Add glossary badge if definition is from glossary
            if (data.source === 'glossary') {
                html += `<div class="glossary-badge mb-2"><span class="badge bg-info text-white">üìö From Glossary</span></div>`;
            }
            
            html += `<div class="dictionary-popup-definition">${escapeHtml(data.definition)}</div>`;
            
            // Add two buttons side by side: Derivation (left) and Examples (right)
            const safeWordId = wordToLookup.replace(/[^a-zA-Z0-9]/g, '_');
            html += `<div class="d-flex gap-2 mt-2 mb-2">
                <button class="btn btn-sm btn-outline-primary flex-fill" onclick="showDerivation('${escapeHtml(wordToLookup)}', this)" id="derivation-btn-${safeWordId}">
                    Derivation
                </button>
                <button class="btn btn-sm btn-outline-primary flex-fill" onclick="showExamplesPopup('${escapeHtml(wordToLookup)}', this)" id="examples-btn-${safeWordId}">
                    Examples
                </button>
            </div>`;
            
            // Containers for derivation and examples (hidden initially)
            html += `<div id="derivation-content-${safeWordId}" class="dictionary-popup-derivation-container" style="display: none;"></div>`;
            html += `<div id="examples-content-${safeWordId}" class="dictionary-popup-examples-container" style="display: none;"></div>`;
            
            // Store examples data for later use
            if (data.example) {
                const examples = data.example.split(' |||| ').map(ex => ex.trim()).filter(ex => ex);
                window[`examples_${safeWordId}`] = examples;
            }
            
            popupContent.innerHTML = html;
            
            // Track dictionary lookup
            trackActivity('DEFINITION_LOOKUP', { word: wordToLookup });
        } else {
            console.log('Word not found in dictionary:', wordToLookup, data); // Debug log
            popupContent.innerHTML = '<div class="dictionary-popup-loading text-muted">Word not found in dictionary.</div>';
        }
    })
    .catch(err => {
        console.error('Error looking up word:', err);
        popupContent.innerHTML = `<div class="dictionary-popup-loading text-danger">Error looking up word: ${err.message}. Please try again.</div>`;
    });
}

// Close popup when clicking outside
document.addEventListener('click', function(event) {
    const popup = document.getElementById('dictionary-popup');
    if (popup && !popup.contains(event.target) && !event.target.classList.contains('word-highlight')) {
        hideDictionaryPopup();
    }
});

// Close popup with Escape key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        hideDictionaryPopup();
    }
});

// Show examples when "See an example" button is clicked (old function - kept for backwards compatibility)
function showExamples(button) {
    if (!button) return;
    
    // Find the examples container (should be the next sibling)
    const container = button.nextElementSibling;
    if (container && container.classList.contains('dictionary-popup-examples-container')) {
        // Show examples
        container.classList.add('show');
        // Hide the "See an example" button
        button.style.display = 'none';
    }
}

// Show derivation (etymology) for a word
function showDerivation(word, button) {
    if (!word || !button) return;
    
    const safeWordId = word.replace(/[^a-zA-Z0-9]/g, '_');
    const container = document.getElementById(`derivation-content-${safeWordId}`);
    
    if (!container) return;
    
    // If already shown, hide it
    if (container.style.display !== 'none') {
        container.style.display = 'none';
        button.classList.remove('btn-primary');
        button.classList.add('btn-outline-primary');
        return;
    }
    
    // Show loading state
    container.innerHTML = '<div class="dictionary-popup-loading">Loading derivation...</div>';
    container.style.display = 'block';
    button.classList.remove('btn-outline-primary');
    button.classList.add('btn-primary');
    
    // Fetch derivation from Wiktionary API (free, no API key needed)
    const normalizedWord = word.toLowerCase().trim();
    fetch(`https://en.wiktionary.org/api/rest_v1/page/etymology/${encodeURIComponent(normalizedWord)}`, {
        method: 'GET',
        headers: {
            'Accept': 'application/json'
        }
    })
    .then(res => {
        if (!res.ok) {
            throw new Error('Etymology not found');
        }
        return res.json();
    })
    .then(data => {
        // Extract etymology text from Wiktionary API response
        let etymologyText = '';
        
        // The API returns etymology in different formats, try to extract text
        if (data.etymology_templates && data.etymology_templates.length > 0) {
            // Has etymology templates
            etymologyText = data.etymology_templates.map(t => t.text || '').join(' ');
        } else if (typeof data === 'string') {
            etymologyText = data;
        } else if (data.text) {
            etymologyText = data.text;
        } else {
            // Try to find etymology in the content
            if (data.etymology) {
                etymologyText = data.etymology;
            }
        }
        
        if (etymologyText && etymologyText.trim()) {
            // Clean up HTML tags if present
            etymologyText = etymologyText.replace(/<[^>]*>/g, '').trim();
            container.innerHTML = `<div class="dictionary-popup-derivation">${escapeHtml(etymologyText)}</div>`;
        } else {
            container.innerHTML = '<div class="dictionary-popup-loading text-muted">Derivation not available for this word.</div>';
        }
    })
    .catch(err => {
        console.error('Error fetching derivation:', err);
        // Try alternative: fetch full page and parse etymology section
        fetch(`https://en.wiktionary.org/api/rest_v1/page/html/${encodeURIComponent(normalizedWord)}`, {
            method: 'GET',
            headers: {
                'Accept': 'text/html'
            }
        })
        .then(res => res.text())
        .then(html => {
            // Simple parsing: look for etymology section
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const etymologySection = doc.querySelector('h2#Etymology, h3#Etymology, .etymology');
            
            if (etymologySection) {
                let etymologyText = etymologySection.textContent || '';
                const nextP = etymologySection.nextElementSibling;
                if (nextP && nextP.tagName === 'P') {
                    etymologyText += ' ' + nextP.textContent;
                }
                etymologyText = etymologyText.replace(/<[^>]*>/g, '').trim();
                
                if (etymologyText) {
                    container.innerHTML = `<div class="dictionary-popup-derivation">${escapeHtml(etymologyText)}</div>`;
                } else {
                    container.innerHTML = '<div class="dictionary-popup-loading text-muted">Derivation not available for this word.</div>';
                }
            } else {
                container.innerHTML = '<div class="dictionary-popup-loading text-muted">Derivation not available for this word.</div>';
            }
        })
        .catch(err2 => {
            container.innerHTML = '<div class="dictionary-popup-loading text-muted">Derivation not available for this word.</div>';
        });
    });
}

// Show examples popup (2-3 examples)
function showExamplesPopup(word, button) {
    if (!word || !button) return;
    
    const safeWordId = word.replace(/[^a-zA-Z0-9]/g, '_');
    const container = document.getElementById(`examples-content-${safeWordId}`);
    
    if (!container) return;
    
    // If already shown, hide it
    if (container.style.display !== 'none') {
        container.style.display = 'none';
        button.classList.remove('btn-primary');
        button.classList.add('btn-outline-primary');
        return;
    }
    
    // Get stored examples
    const examples = window[`examples_${safeWordId}`] || [];
    
    if (examples.length === 0) {
        container.innerHTML = '<div class="dictionary-popup-loading text-muted">No examples available for this word.</div>';
        container.style.display = 'block';
        return;
    }
    
    // Show 2-3 examples
    const examplesToShow = examples.slice(0, 3);
    let examplesHtml = examplesToShow.map(ex => `<div class="dictionary-popup-example">${escapeHtml(ex)}</div>`).join('');
    
    container.innerHTML = examplesHtml;
    container.style.display = 'block';
    button.classList.remove('btn-outline-primary');
    button.classList.add('btn-primary');
}

// Show more examples when button is clicked (for inline popup - when 3+ examples)
function showMoreExamples(button) {
    if (!button) return;
    
    // Find the additional examples container (should be the next sibling)
    const container = button.nextElementSibling;
    if (container && container.classList.contains('dictionary-popup-additional-examples')) {
        // Toggle visibility
        if (container.classList.contains('show')) {
            // Hide additional examples
            container.classList.remove('show');
            // Update button text - extract the number from current text
            const currentText = button.textContent.trim();
            if (currentText.includes('Hide')) {
                // Extract number and restore "See X more examples"
                const match = currentText.match(/\d+/);
                if (match) {
                    const count = parseInt(match[0]);
                    button.textContent = `See ${count} more example${count > 1 ? 's' : ''}`;
                }
            }
        } else {
            // Show additional examples
            container.classList.add('show');
            // Update button text
            const currentText = button.textContent.trim();
            if (currentText.includes('See')) {
                // Extract number and change to "Hide X more examples"
                const match = currentText.match(/\d+/);
                if (match) {
                    const count = parseInt(match[0]);
                    button.textContent = `Hide ${count} more example${count > 1 ? 's' : ''}`;
                }
            }
        }
    }
}

// Show examples when "See an example" button is clicked (for modal)
function showExamplesModal(button) {
    if (!button) return;
    
    // Find the examples container (should be the next sibling)
    const container = button.nextElementSibling;
    if (container && container.classList.contains('dictionary-popup-examples-container')) {
        // Show examples
        container.style.display = 'block';
        // Hide the "See an example" button
        button.style.display = 'none';
    }
}

// Show more examples when button is clicked (for modal - when 3+ examples)
function showMoreExamplesModal(button) {
    if (!button) return;
    
    // Find the additional examples container (should be the next sibling)
    const container = button.nextElementSibling;
    if (container && container.classList.contains('dictionary-popup-additional-examples')) {
        // Toggle visibility
        if (container.style.display === 'block' || container.classList.contains('show')) {
            // Hide additional examples
            container.style.display = 'none';
            container.classList.remove('show');
            // Update button text
            const currentText = button.textContent.trim();
            if (currentText.includes('Hide')) {
                const match = currentText.match(/\d+/);
                if (match) {
                    const count = parseInt(match[0]);
                    button.textContent = `See ${count} more example${count > 1 ? 's' : ''}`;
                }
            }
        } else {
            // Show additional examples
            container.style.display = 'block';
            container.classList.add('show');
            // Update button text
            const currentText = button.textContent.trim();
            if (currentText.includes('See')) {
                const match = currentText.match(/\d+/);
                if (match) {
                    const count = parseInt(match[0]);
                    button.textContent = `Hide ${count} more example${count > 1 ? 's' : ''}`;
                }
            }
        }
    }
}

// Lookup word for modal (manual dictionary lookup)
function lookupWord(word) {
    const lookupWordInput = document.getElementById('lookup-word');
    const wordToLookup = word || lookupWordInput.value;
    
    if (!wordToLookup) return;

    const token = getAuthToken();
    const resultDiv = document.getElementById('dictionary-result');
    
    if (resultDiv) {
        resultDiv.innerHTML = '<p class="text-muted">Loading...</p>';
    }
    
    fetch('/rest/v1/rpc/get_definition_with_context', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
            term: wordToLookup,
            book_id: bookId
        })
    })
    .then(res => res.json())
    .then(data => {
        if (resultDiv) {
            if (data.definition && data.definition !== 'Word not found in dictionary.') {
                let html = '';
                
                // Add glossary badge if definition is from glossary
                if (data.source === 'glossary') {
                    html += `<div class="glossary-badge mb-2"><span class="badge bg-info text-white">üìö From Glossary</span></div>`;
                }
                
                let exampleHtml = '';
                
                // Handle examples: Hidden by default, show with "See an example" button
                if (data.example) {
                    const examples = data.example.split(' |||| ').map(ex => ex.trim()).filter(ex => ex);
                    
                    if (examples.length > 0) {
                        // Build examples HTML (hidden initially)
                        let examplesContent = '';
                        if (examples.length === 1) {
                            examplesContent = `<p class="text-muted"><em>${escapeHtml(examples[0])}</em></p>`;
                        } else if (examples.length === 2) {
                            examplesContent = examples.map(ex => `<p class="text-muted"><em>${escapeHtml(ex)}</em></p>`).join('');
                        } else if (examples.length >= 3) {
                            // Show first 2, then button for rest
                            const firstTwo = examples.slice(0, 2);
                            const rest = examples.slice(2);
                            examplesContent = firstTwo.map(ex => `<p class="text-muted"><em>${escapeHtml(ex)}</em></p>`).join('');
                            
                            if (rest.length > 0) {
                                examplesContent += `<button class="btn btn-sm btn-outline-secondary mt-2 dictionary-popup-more-examples" onclick="showMoreExamplesModal(this)">
                                    See ${rest.length} more example${rest.length > 1 ? 's' : ''}
                                </button>`;
                                examplesContent += `<div class="mt-2 dictionary-popup-additional-examples">
                                    ${rest.map(ex => `<p class="text-muted"><em>${escapeHtml(ex)}</em></p>`).join('')}
                                </div>`;
                            }
                        }
                        
                        // Determine button text
                        let buttonText = 'See an example';
                        if (examples.length === 2) {
                            buttonText = 'See 2 examples';
                        } else if (examples.length > 2) {
                            buttonText = 'See examples';
                        }
                        
                        // Button and hidden container
                        exampleHtml = `<button class="btn btn-sm btn-outline-secondary mt-2 dictionary-popup-see-example" onclick="showExamplesModal(this)">
                            ${escapeHtml(buttonText)}
                        </button>`;
                        exampleHtml += `<div class="dictionary-popup-examples-container mt-2" style="display: none;">
                            ${examplesContent}
                        </div>`;
                    }
                }
                
            // Build HTML with glossary badge if from glossary
            let badgeHtml = '';
            if (data.source === 'glossary') {
                badgeHtml = `<div class="glossary-badge mb-2"><span class="badge bg-info text-white">üìö From Glossary</span></div>`;
            }
            
            resultDiv.innerHTML = `
                <div class="card">
                    <div class="card-body">
                            <h6>${escapeHtml(data.term || wordToLookup)}</h6>
                            ${badgeHtml}
                            <p>${escapeHtml(data.definition)}</p>
                            ${exampleHtml}
                    </div>
                </div>
            `;
            // Track dictionary lookup
            trackActivity('DEFINITION_LOOKUP', { word: wordToLookup });
        } else {
                resultDiv.innerHTML = '<p class="text-muted">Word not found in dictionary.</p>';
            }
        }
    })
    .catch(err => {
        console.error('Error looking up word:', err);
        if (resultDiv) {
            resultDiv.innerHTML = '<p class="text-danger">Error looking up word. Please try again.</p>';
        }
    });
}

function trackActivity(eventType, data) {
    const token = getAuthToken();
    if (!token) return;

    fetch('/auth/v1/user', {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(res => res.json())
    .then(user => {
        // Log the data being sent for debugging
        if (eventType === 'PAGE_SYNC' && data.section_index !== undefined) {
            console.log('[trackActivity] Tracking PAGE_SYNC with section_index:', data);
        }
        return fetch('/api/activity/track', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + token
            },
            body: JSON.stringify({
                user_id: user.id,
                event_type: eventType,
                book_id: bookId,
                context: data
            })
        });
    })
    .catch(err => console.error('Error tracking activity:', err));
}

function goToPage() {
    // Preserve scroll position to prevent jumping on mobile
    const scrollPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    
    const pageInput = document.getElementById('page-number');
    const page = parseInt(pageInput.value);
    if (page > 0) {
        loadPage(page);
        
        // Restore scroll position after content loads
        setTimeout(() => {
            window.scrollTo(0, scrollPosition);
        }, 100);
    }
}

function previousPage() {
    // Preserve scroll position to prevent jumping on mobile
    const scrollPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    
    if (currentPage > 1) {
        loadPage(currentPage - 1);
        
        // Restore scroll position after content loads
        setTimeout(() => {
            window.scrollTo(0, scrollPosition);
        }, 100);
    }
}

function nextPage() {
    // Preserve scroll position to prevent jumping on mobile
    const scrollPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    
    loadPage(currentPage + 1);
    
    // Restore scroll position after content loads
    setTimeout(() => {
        window.scrollTo(0, scrollPosition);
    }, 100);
}

function showDictionary() {
    const modal = new bootstrap.Modal(document.getElementById('dictionaryModal'));
    modal.show();
}

// Variables for AI modal dragging
let isDraggingAIModal = false;
let aiModalDragStartX = 0;
let aiModalDragStartY = 0;
let aiModalStartX = 0;
let aiModalStartY = 0;

// Drag state for AI chat container
let isDraggingAIChat = false;
let aiChatDragStartX = 0;
let aiChatDragStartY = 0;
let aiChatStartX = 0;
let aiChatStartY = 0;

// Resize state for AI chat container
let isResizingAIChat = false;
let aiChatResizeStartX = 0;
let aiChatResizeStartY = 0;
let aiChatStartWidth = 0;
let aiChatStartHeight = 0;

// Variables for AI modal resizing
let isResizingAIModal = false;
let aiModalResizeStartX = 0;
let aiModalResizeStartY = 0;
let aiModalStartWidth = 0;
let aiModalStartHeight = 0;

// Initialize resize functionality for AI Help modal
function initAIHelpModalResize() {
    const modalDialog = document.getElementById('aiHelpModalDialog');
    const resizeHandle = document.getElementById('aiHelpModalResizeHandle');
    
    if (!modalDialog || !resizeHandle) return;
    
    // Mouse events for resize
    resizeHandle.addEventListener('mousedown', function(e) {
        startAIModalResize(e, modalDialog);
        e.stopPropagation();
        e.preventDefault();
    });
    
    // Touch events for mobile
    resizeHandle.addEventListener('touchstart', function(e) {
        startAIModalResizeTouch(e, modalDialog);
        e.stopPropagation();
        e.preventDefault();
    }, { passive: false });
    
    function startAIModalResize(e, dialog) {
        isResizingAIModal = true;
        aiModalResizeStartX = e.clientX;
        aiModalResizeStartY = e.clientY;
        const rect = dialog.getBoundingClientRect();
        aiModalStartWidth = rect.width;
        aiModalStartHeight = rect.height;
        
        document.addEventListener('mousemove', resizeAIModalHandler);
        document.addEventListener('mouseup', stopAIModalResizeHandler);
    }
    
    function startAIModalResizeTouch(e, dialog) {
        const touch = e.touches[0];
        isResizingAIModal = true;
        aiModalResizeStartX = touch.clientX;
        aiModalResizeStartY = touch.clientY;
        const rect = dialog.getBoundingClientRect();
        aiModalStartWidth = rect.width;
        aiModalStartHeight = rect.height;
        
        document.addEventListener('touchmove', resizeAIModalTouchHandler, { passive: false });
        document.addEventListener('touchend', stopAIModalResizeHandler);
    }
    
    function resizeAIModalHandler(e) {
        if (!isResizingAIModal) return;
        const deltaX = e.clientX - aiModalResizeStartX;
        const deltaY = e.clientY - aiModalResizeStartY;
        
        const newWidth = Math.max(400, Math.min(800, aiModalStartWidth + deltaX));
        const newHeight = Math.max(250, Math.min(window.innerHeight * 0.9, aiModalStartHeight + deltaY));
        
        modalDialog.style.width = newWidth + 'px';
        modalDialog.style.height = newHeight + 'px';
        
        e.preventDefault();
    }
    
    function resizeAIModalTouchHandler(e) {
        if (!isResizingAIModal) return;
        const touch = e.touches[0];
        const deltaX = touch.clientX - aiModalResizeStartX;
        const deltaY = touch.clientY - aiModalResizeStartY;
        
        const newWidth = Math.max(400, Math.min(800, aiModalStartWidth + deltaX));
        const newHeight = Math.max(250, Math.min(window.innerHeight * 0.9, aiModalStartHeight + deltaY));
        
        modalDialog.style.width = newWidth + 'px';
        modalDialog.style.height = newHeight + 'px';
        
        e.preventDefault();
    }
    
    function stopAIModalResizeHandler() {
        if (isResizingAIModal) {
            isResizingAIModal = false;
            document.removeEventListener('mousemove', resizeAIModalHandler);
            document.removeEventListener('mouseup', stopAIModalResizeHandler);
            document.removeEventListener('touchmove', resizeAIModalTouchHandler);
            document.removeEventListener('touchend', stopAIModalResizeHandler);
        }
    }
}

// Initialize drag functionality for AI Help modal
function initAIHelpModalDrag() {
    const modalDialog = document.getElementById('aiHelpModalDialog');
    const dragHandle = document.getElementById('aiHelpModalDragHandle');
    
    if (!modalDialog || !dragHandle) return;
    
    // Remove old event listeners by cloning (clean slate)
    const dragHandleClone = dragHandle.cloneNode(true);
    dragHandle.parentNode.replaceChild(dragHandleClone, dragHandle);
    
    // Mouse events
    dragHandleClone.addEventListener('mousedown', function(e) {
        startAIModalDrag(e, modalDialog, dragHandleClone);
    });
    
    // Touch events for mobile
    dragHandleClone.addEventListener('touchstart', function(e) {
        startAIModalDragTouch(e, modalDialog);
    }, { passive: false });
    
    function startAIModalDrag(e, dialog, handle) {
        if (e.target.classList.contains('btn-close')) {
            return; // Don't start drag if clicking close button
        }
        isDraggingAIModal = true;
        aiModalDragStartX = e.clientX;
        aiModalDragStartY = e.clientY;
        const rect = dialog.getBoundingClientRect();
        aiModalStartX = rect.left;
        aiModalStartY = rect.top;
        handle.style.cursor = 'grabbing';
        e.preventDefault();
        
        document.addEventListener('mousemove', dragAIModalHandler);
        document.addEventListener('mouseup', stopAIModalDragHandler);
    }
    
    function startAIModalDragTouch(e, dialog) {
        if (e.target.classList.contains('btn-close')) {
            return;
        }
        const touch = e.touches[0];
        isDraggingAIModal = true;
        aiModalDragStartX = touch.clientX;
        aiModalDragStartY = touch.clientY;
        const rect = dialog.getBoundingClientRect();
        aiModalStartX = rect.left;
        aiModalStartY = rect.top;
        e.preventDefault();
        
        document.addEventListener('touchmove', dragAIModalTouchHandler, { passive: false });
        document.addEventListener('touchend', stopAIModalDragHandler);
    }
    
    function dragAIModalHandler(e) {
        if (!isDraggingAIModal) return;
        const deltaX = e.clientX - aiModalDragStartX;
        const deltaY = e.clientY - aiModalDragStartY;
        modalDialog.style.left = (aiModalStartX + deltaX) + 'px';
        modalDialog.style.top = (aiModalStartY + deltaY) + 'px';
        modalDialog.style.transform = 'none';
        modalDialog.style.margin = '0';
        e.preventDefault();
    }
    
    function dragAIModalTouchHandler(e) {
        if (!isDraggingAIModal) return;
        const touch = e.touches[0];
        const deltaX = touch.clientX - aiModalDragStartX;
        const deltaY = touch.clientY - aiModalDragStartY;
        modalDialog.style.left = (aiModalStartX + deltaX) + 'px';
        modalDialog.style.top = (aiModalStartY + deltaY) + 'px';
        modalDialog.style.transform = 'none';
        modalDialog.style.margin = '0';
        e.preventDefault();
    }
    
    function stopAIModalDragHandler() {
        if (isDraggingAIModal) {
            isDraggingAIModal = false;
            const handle = document.getElementById('aiHelpModalDragHandle');
            if (handle) handle.style.cursor = 'move';
            document.removeEventListener('mousemove', dragAIModalHandler);
            document.removeEventListener('mouseup', stopAIModalDragHandler);
            document.removeEventListener('touchmove', dragAIModalTouchHandler);
            document.removeEventListener('touchend', stopAIModalDragHandler);
        }
    }
}

// Store modal instance globally to prevent closing on backdrop click
let aiHelpModalInstance = null;
let isChatMinimized = false;
let minimizeTimeout = null;

// Minimize chat to bottom bar
function minimizeAIChatToBottom() {
    const chatContainer = document.getElementById('ai-chat-container');
    const minimizedBar = document.getElementById('ai-chat-minimized');
    
    if (chatContainer && minimizedBar) {
        chatContainer.style.display = 'none';
        minimizedBar.style.display = 'block';
        isChatMinimized = true;
    }
}

// Expand chat from bottom bar
function expandAIChatFromBottom() {
    const chatContainer = document.getElementById('ai-chat-container');
    const minimizedBar = document.getElementById('ai-chat-minimized');
    
    if (chatContainer && minimizedBar) {
        chatContainer.style.display = 'flex';
        minimizedBar.style.display = 'none';
        isChatMinimized = false;
        // Scroll to bottom
        scrollChatToBottom();
    }
}

// Close chat completely
function closeAIChat() {
    const chatContainer = document.getElementById('ai-chat-container');
    const minimizedBar = document.getElementById('ai-chat-minimized');
    
    if (chatContainer) chatContainer.style.display = 'none';
    if (minimizedBar) minimizedBar.style.display = 'none';
    isChatMinimized = false;
    disableAIChatTextSelection();
}

// Toggle chat resize (small -> medium -> large -> small)
let chatResizeState = 'medium'; // 'small', 'medium', 'large'

function toggleAIChatResize() {
    const chatContainer = document.getElementById('ai-chat-container');
    const resizeBtn = document.getElementById('ai-chat-resize-btn');
    
    if (!chatContainer) return;
    
    // Remove all resize classes
    chatContainer.classList.remove('resized-small', 'resized-large');
    
    // Cycle through sizes
    if (chatResizeState === 'medium') {
        chatResizeState = 'large';
        chatContainer.classList.add('resized-large');
        if (resizeBtn) resizeBtn.textContent = '‚§°';
        if (resizeBtn) resizeBtn.title = 'Make smaller';
    } else if (chatResizeState === 'large') {
        chatResizeState = 'small';
        chatContainer.classList.add('resized-small');
        if (resizeBtn) resizeBtn.textContent = '‚§¢';
        if (resizeBtn) resizeBtn.title = 'Make larger';
    } else {
        chatResizeState = 'medium';
        // Default size (no class)
        if (resizeBtn) resizeBtn.textContent = '‚§¢';
        if (resizeBtn) resizeBtn.title = 'Resize';
    }
}

// Initialize drag functionality for AI chat container
function initAIChatDrag() {
    const chatContainer = document.getElementById('ai-chat-container');
    const chatHeader = document.getElementById('ai-chat-header');
    
    if (!chatContainer || !chatHeader) return;
    
    // Check if already initialized
    if (chatHeader.dataset.dragInitialized === 'true') return;
    chatHeader.dataset.dragInitialized = 'true';
    
    // Mouse events
    chatHeader.addEventListener('mousedown', function(e) {
        // Don't start drag if clicking on buttons
        if (e.target.classList.contains('ai-chat-header-btn') || 
            e.target.closest('.ai-chat-header-btn')) {
            return;
        }
        startAIChatDrag(e, chatContainer, chatHeader);
    });
    
    // Touch events for mobile
    chatHeader.addEventListener('touchstart', function(e) {
        // Don't start drag if clicking on buttons
        if (e.target.classList.contains('ai-chat-header-btn') || 
            e.target.closest('.ai-chat-header-btn')) {
            return;
        }
        startAIChatDragTouch(e, chatContainer);
    }, { passive: false });
    
    function startAIChatDrag(e, container, header) {
        isDraggingAIChat = true;
        aiChatDragStartX = e.clientX;
        aiChatDragStartY = e.clientY;
        const rect = container.getBoundingClientRect();
        aiChatStartX = rect.left;
        aiChatStartY = rect.top;
        header.classList.add('dragging');
        container.classList.add('dragging');
        e.preventDefault();
        
        document.addEventListener('mousemove', dragAIChatHandler);
        document.addEventListener('mouseup', stopAIChatDragHandler);
    }
    
    function startAIChatDragTouch(e, container) {
        const touch = e.touches[0];
        isDraggingAIChat = true;
        aiChatDragStartX = touch.clientX;
        aiChatDragStartY = touch.clientY;
        const rect = container.getBoundingClientRect();
        aiChatStartX = rect.left;
        aiChatStartY = rect.top;
        const header = document.getElementById('ai-chat-header');
        if (header) header.classList.add('dragging');
        container.classList.add('dragging');
        e.preventDefault();
        
        document.addEventListener('touchmove', dragAIChatTouchHandler, { passive: false });
        document.addEventListener('touchend', stopAIChatDragHandler);
    }
    
    function dragAIChatHandler(e) {
        if (!isDraggingAIChat) return;
        const deltaX = e.clientX - aiChatDragStartX;
        const deltaY = e.clientY - aiChatDragStartY;
        
        // Calculate new position
        let newX = aiChatStartX + deltaX;
        let newY = aiChatStartY + deltaY;
        
        // Keep within viewport bounds
        const container = document.getElementById('ai-chat-container');
        if (!container) return;
        const rect = container.getBoundingClientRect();
        const maxX = window.innerWidth - rect.width;
        const maxY = window.innerHeight - rect.height;
        
        newX = Math.max(0, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));
        
        // Update position
        container.style.left = newX + 'px';
        container.style.top = newY + 'px';
        container.style.right = 'auto';
        container.style.bottom = 'auto';
        e.preventDefault();
    }
    
    function dragAIChatTouchHandler(e) {
        if (!isDraggingAIChat) return;
        const touch = e.touches[0];
        const deltaX = touch.clientX - aiChatDragStartX;
        const deltaY = touch.clientY - aiChatDragStartY;
        
        // Calculate new position
        let newX = aiChatStartX + deltaX;
        let newY = aiChatStartY + deltaY;
        
        // Keep within viewport bounds
        const container = document.getElementById('ai-chat-container');
        if (!container) return;
        const rect = container.getBoundingClientRect();
        const maxX = window.innerWidth - rect.width;
        const maxY = window.innerHeight - rect.height;
        
        newX = Math.max(0, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));
        
        // Update position
        container.style.left = newX + 'px';
        container.style.top = newY + 'px';
        container.style.right = 'auto';
        container.style.bottom = 'auto';
        e.preventDefault();
    }
    
    function stopAIChatDragHandler() {
        if (isDraggingAIChat) {
            isDraggingAIChat = false;
            const header = document.getElementById('ai-chat-header');
            const container = document.getElementById('ai-chat-container');
            if (header) header.classList.remove('dragging');
            if (container) container.classList.remove('dragging');
            document.removeEventListener('mousemove', dragAIChatHandler);
            document.removeEventListener('mouseup', stopAIChatDragHandler);
            document.removeEventListener('touchmove', dragAIChatTouchHandler);
            document.removeEventListener('touchend', stopAIChatDragHandler);
        }
    }
}

// Check if point is inside the chat modal
function isInsideChatModal(x, y) {
    const modalDialog = document.getElementById('aiHelpModalDialog');
    if (!modalDialog) return false;
    
    const rect = modalDialog.getBoundingClientRect();
    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

// Handle mouse/touch movement - auto-minimize when outside
function handleOutsideChatInteraction(e) {
    const modalElement = document.getElementById('aiHelpModal');
    if (!modalElement || !modalElement.classList.contains('show')) return;
    if (isChatMinimized) return; // Don't do anything if already minimized
    
    // Don't minimize if user is interacting with chat elements
    const target = e.target;
    if (target && modalElement.contains(target)) {
        // Clear any pending minimize if user is inside chat
        if (minimizeTimeout) {
            clearTimeout(minimizeTimeout);
            minimizeTimeout = null;
        }
        return;
    }
    
    const x = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
    const y = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
    
    // Clear any existing timeout
    if (minimizeTimeout) {
        clearTimeout(minimizeTimeout);
    }
    
    // If outside the chat, minimize after a short delay
    if (!isInsideChatModal(x, y)) {
        minimizeTimeout = setTimeout(() => {
            // Double-check user is still outside before minimizing
            if (!isInsideChatModal(x, y) && !isChatMinimized) {
                minimizeAIChat();
            }
        }, 800); // 800ms delay before minimizing (gives user time to move back)
    } else {
        // User moved back inside - cancel minimize
        if (minimizeTimeout) {
            clearTimeout(minimizeTimeout);
            minimizeTimeout = null;
        }
    }
}

// Show AI Help - WhatsApp style floating chat
function showAIHelp() {
    const chatContainer = document.getElementById('ai-chat-container');
    const minimizedBar = document.getElementById('ai-chat-minimized');
    
    // If minimized, expand it
    if (isChatMinimized && minimizedBar && minimizedBar.style.display !== 'none') {
        expandAIChatFromBottom();
        return;
    }
    
    // Show the floating chat container
    if (chatContainer) {
        chatContainer.style.display = 'flex';
        if (minimizedBar) minimizedBar.style.display = 'none';
        isChatMinimized = false;
        
        // Add click listener to page content to minimize when clicking text
        const pageContent = document.getElementById('page-content');
        if (pageContent && !pageContent.dataset.chatMinimizeListener) {
            pageContent.dataset.chatMinimizeListener = 'true';
            pageContent.addEventListener('click', function handlePageClick(e) {
                // Don't minimize if clicking inside chat
                const chatContainer = document.getElementById('ai-chat-container');
                if (chatContainer && chatContainer.contains(e.target)) {
                    return;
                }
                // Don't minimize if clicking on selection toolbar or other UI elements
                if (e.target.closest('.selection-toolbar') || 
                    e.target.closest('.selection-mode-indicator') ||
                    e.target.closest('.dictionary-popup')) {
                    return;
                }
                // Minimize chat when clicking on page content
                minimizeAIChatToBottom();
            });
        }
        
        // Clear input
        const questionInput = document.getElementById('ai-question');
        if (questionInput) {
            questionInput.value = '';
            questionInput.style.height = 'auto';
            
            // Auto-resize textarea on input
            questionInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
            });
        }
        
        // Focus on input after a short delay
        setTimeout(() => {
            if (questionInput) {
                questionInput.focus();
            }
        }, 100);
        
        // Load conversation history
        loadAIConversationHistory();
        
        // Initialize drag and resize functionality
        setTimeout(() => {
            initAIChatDrag();
            initAIChatResize();
        }, 100);
        
        // Scroll to bottom
        scrollChatToBottom();
    }
}

// Initialize resize functionality for AI chat container
function initAIChatResize() {
    const chatContainer = document.getElementById('ai-chat-container');
    const resizeHandle = document.getElementById('ai-chat-resize-handle');
    
    if (!chatContainer || !resizeHandle) return;
    
    // Check if already initialized
    if (resizeHandle.dataset.resizeInitialized === 'true') return;
    resizeHandle.dataset.resizeInitialized = 'true';
    
    // Mouse events
    resizeHandle.addEventListener('mousedown', function(e) {
        startAIChatResize(e, chatContainer);
    });
    
    // Touch events for mobile
    resizeHandle.addEventListener('touchstart', function(e) {
        startAIChatResizeTouch(e, chatContainer);
    }, { passive: false });
    
    function startAIChatResize(e, container) {
        isResizingAIChat = true;
        aiChatResizeStartX = e.clientX;
        aiChatResizeStartY = e.clientY;
        const rect = container.getBoundingClientRect();
        aiChatStartWidth = rect.width;
        aiChatStartHeight = rect.height;
        aiChatStartX = rect.left;
        aiChatStartY = rect.top;
        container.classList.add('resizing');
        e.preventDefault();
        e.stopPropagation();
        
        document.addEventListener('mousemove', resizeAIChatHandler);
        document.addEventListener('mouseup', stopAIChatResizeHandler);
    }
    
    function startAIChatResizeTouch(e, container) {
        const touch = e.touches[0];
        isResizingAIChat = true;
        aiChatResizeStartX = touch.clientX;
        aiChatResizeStartY = touch.clientY;
        const rect = container.getBoundingClientRect();
        aiChatStartWidth = rect.width;
        aiChatStartHeight = rect.height;
        aiChatStartX = rect.left;
        aiChatStartY = rect.top;
        container.classList.add('resizing');
        e.preventDefault();
        e.stopPropagation();
        
        document.addEventListener('touchmove', resizeAIChatTouchHandler, { passive: false });
        document.addEventListener('touchend', stopAIChatResizeHandler);
    }
    
    function resizeAIChatHandler(e) {
        if (!isResizingAIChat) return;
        
        const deltaX = e.clientX - aiChatResizeStartX;
        const deltaY = e.clientY - aiChatResizeStartY;
        
        // Calculate new dimensions
        let newWidth = aiChatStartWidth + deltaX;
        let newHeight = aiChatStartHeight + deltaY;
        
        // Minimum and maximum sizes
        const minWidth = 280;
        const maxWidth = Math.min(window.innerWidth - 40, 800);
        const minHeight = 300;
        const maxHeight = Math.min(window.innerHeight - 40, window.innerHeight - 20);
        
        newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
        newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));
        
        // Update container size
        const container = document.getElementById('ai-chat-container');
        if (!container) return;
        
        container.style.width = newWidth + 'px';
        container.style.height = newHeight + 'px';
        
        // Remove fixed size classes when manually resizing
        container.classList.remove('resized-small', 'resized-large');
        chatResizeState = 'custom';
        
        // Ensure container stays within viewport
        const rect = container.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            container.style.left = (window.innerWidth - newWidth) + 'px';
            container.style.right = 'auto';
        }
        if (rect.bottom > window.innerHeight) {
            container.style.top = (window.innerHeight - newHeight) + 'px';
            container.style.bottom = 'auto';
        }
        
        e.preventDefault();
    }
    
    function resizeAIChatTouchHandler(e) {
        if (!isResizingAIChat) return;
        const touch = e.touches[0];
        
        const deltaX = touch.clientX - aiChatResizeStartX;
        const deltaY = touch.clientY - aiChatResizeStartY;
        
        // Calculate new dimensions
        let newWidth = aiChatStartWidth + deltaX;
        let newHeight = aiChatStartHeight + deltaY;
        
        // Minimum and maximum sizes
        const minWidth = 280;
        const maxWidth = Math.min(window.innerWidth - 40, 800);
        const minHeight = 300;
        const maxHeight = Math.min(window.innerHeight - 40, window.innerHeight - 20);
        
        newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
        newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));
        
        // Update container size
        const container = document.getElementById('ai-chat-container');
        if (!container) return;
        
        container.style.width = newWidth + 'px';
        container.style.height = newHeight + 'px';
        
        // Remove fixed size classes when manually resizing
        container.classList.remove('resized-small', 'resized-large');
        chatResizeState = 'custom';
        
        // Ensure container stays within viewport
        const rect = container.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            container.style.left = (window.innerWidth - newWidth) + 'px';
            container.style.right = 'auto';
        }
        if (rect.bottom > window.innerHeight) {
            container.style.top = (window.innerHeight - newHeight) + 'px';
            container.style.bottom = 'auto';
        }
        
        e.preventDefault();
    }
    
    function stopAIChatResizeHandler() {
        if (isResizingAIChat) {
            isResizingAIChat = false;
            const container = document.getElementById('ai-chat-container');
            if (container) container.classList.remove('resizing');
            document.removeEventListener('mousemove', resizeAIChatHandler);
            document.removeEventListener('mouseup', stopAIChatResizeHandler);
            document.removeEventListener('touchmove', resizeAIChatTouchHandler);
            document.removeEventListener('touchend', stopAIChatResizeHandler);
        }
    }
}

// Activate text selection mode (called by button click)
function activateTextSelectionMode() {
    aiChatSelectionModeActive = true;
    textSelectionModeActive = true;
    
    // Update button appearance
    const selectBtn = document.getElementById('ai-select-text-btn');
    if (selectBtn) {
        selectBtn.disabled = true;
        selectBtn.classList.remove('btn-outline-primary');
        selectBtn.classList.add('btn-primary');
        selectBtn.innerHTML = '<span>‚úì</span> <span>Selection mode active - Select text and press Enter</span>';
    }
    
    // Hide selection status (will show when text is selected)
    const statusDiv = document.getElementById('ai-chat-selection-status');
    if (statusDiv) {
        statusDiv.style.display = 'none';
    }
    
    const pageContent = document.getElementById('page-content');
    const readingContainer = document.getElementById('reading-container');
    const chatMessages = document.getElementById('ai-chat-messages');
    
    if (pageContent) {
        pageContent.classList.add('text-selection-active');
        readingContainer.classList.add('text-selection-active');
    }
    
    // Enable text selection on chat messages
    if (chatMessages) {
        chatMessages.classList.add('text-selection-active');
        enableChatMessagesTextSelection();
    }
    
    // Make modal backdrop and dialog allow interaction with page behind it
    const adjustModalForSelection = () => {
        const backdrop = document.querySelector('.modal-backdrop');
        const modalDialog = document.getElementById('aiHelpModalDialog');
        const modal = document.getElementById('aiHelpModal');
        
        if (backdrop) {
            backdrop.style.pointerEvents = 'none';
            backdrop.style.backgroundColor = 'transparent'; // No grey backdrop - completely transparent
        }
        
        // Make modal element itself allow pointer events through (except where we explicitly enable)
        if (modal) {
            modal.style.pointerEvents = 'none';
        }
        
        // Make modal dialog and content allow pointer events to pass through
        if (modalDialog) {
            modalDialog.style.pointerEvents = 'none';
        }
        
        const modalContent = modalDialog ? modalDialog.querySelector('.modal-content') : null;
        if (modalContent) {
            // Make modal content allow pointer events through by default
            modalContent.style.pointerEvents = 'none';
            
            // But allow interaction with specific interactive elements
            const interactiveElements = modalContent.querySelectorAll(
                'button, textarea, input, #ai-chat-messages, .chat-message, .chat-bubble, .modal-header, .modal-body, .border-top'
            );
            interactiveElements.forEach(el => {
                el.style.pointerEvents = 'auto';
            });
            
            // Also make sure the entire chat messages container is interactive
            const chatMessages = document.getElementById('ai-chat-messages');
            if (chatMessages) {
                chatMessages.style.pointerEvents = 'auto';
            }
        }
        
        // If backdrop or dialog don't exist yet, try again
        if (!backdrop || !modalDialog) {
            setTimeout(adjustModalForSelection, 50);
        }
    };
    adjustModalForSelection();
    
    // Enable selection on the page
    enableTextSelection();
    
    // Add global Enter key handler to copy selected text
    document.addEventListener('keydown', handleGlobalEnterKey, true);
}

// Enable text selection when AI chat modal is open (automatic - not used anymore)
function enableAIChatTextSelection() {
    // This function is no longer automatically called
    // Selection is now activated via button click only
}

// Disable text selection when AI chat modal closes or selection completes
function disableAIChatTextSelection() {
    aiChatSelectionModeActive = false;
    textSelectionModeActive = selectionToolbarAlwaysOn;
    
    // Reset button appearance
    const selectBtn = document.getElementById('ai-select-text-btn');
    if (selectBtn) {
        selectBtn.disabled = false;
        selectBtn.classList.remove('btn-primary');
        selectBtn.classList.add('btn-outline-primary');
        selectBtn.innerHTML = '<span>‚úèÔ∏è</span> <span>Select the text you want to clarify</span>';
    }
    
    // Hide selection status
    const statusDiv = document.getElementById('ai-chat-selection-status');
    if (statusDiv) {
        statusDiv.style.display = 'none';
    }
    
    const pageContent = document.getElementById('page-content');
    const readingContainer = document.getElementById('reading-container');
    const chatMessages = document.getElementById('ai-chat-messages');
    
    if (pageContent) {
        pageContent.classList.remove('text-selection-active');
        readingContainer.classList.remove('text-selection-active');
    }
    
    // Disable text selection on chat messages
    if (chatMessages) {
        chatMessages.classList.remove('text-selection-active');
        disableChatMessagesTextSelection();
    }
    
    // Restore modal backdrop and dialog (if modal is still open)
    setTimeout(() => {
        const backdrop = document.querySelector('.modal-backdrop');
        const modalDialog = document.getElementById('aiHelpModalDialog');
        const modal = document.getElementById('aiHelpModal');
        const modalContent = modalDialog ? modalDialog.querySelector('.modal-content') : null;
        
        if (backdrop) {
            backdrop.style.pointerEvents = 'auto';
            backdrop.style.backgroundColor = '';
        }
        
        if (modal) {
            modal.style.pointerEvents = 'auto';
        }
        
        if (modalDialog) {
            modalDialog.style.pointerEvents = 'auto';
        }
        
        if (modalContent) {
            modalContent.style.pointerEvents = 'auto';
            
            // Reset all interactive elements to default
            const interactiveElements = modalContent.querySelectorAll(
                'button, textarea, input, #ai-chat-messages, .chat-message, .chat-bubble, .modal-header, .modal-body, .border-top'
            );
            interactiveElements.forEach(el => {
                el.style.pointerEvents = '';
            });
        }
    }, 100);
    
    clearSelection();
    disableTextSelection();
    
    // Remove global Enter key handler
    document.removeEventListener('keydown', handleGlobalEnterKey, true);
}

// Load conversation history for current book
function loadAIConversationHistory() {
    const token = getAuthToken();
    if (!token || !bookId) {
        return;
    }
    
    const messagesContainer = document.getElementById('ai-chat-messages');
    const emptyState = document.getElementById('ai-chat-empty-state');
    
    // Show loading state
    messagesContainer.innerHTML = '<div class="text-center text-muted py-5">Loading conversation...</div>';
    
    // Get user ID (try cached first, then fetch if needed)
    let userId = getCurrentUserID();
    
    // If no user ID yet, fetch it from API
    if (!userId) {
        fetch('/auth/v1/user', {
            headers: {'Authorization': 'Bearer ' + token}
        })
        .then(r => r.json())
        .then(user => {
            if (user && user.id) {
                cachedUserID = user.id;
                window.currentUser = user;
                loadConversationForUser(user.id);
            } else {
                messagesContainer.innerHTML = '<div class="text-center text-danger py-5">Error: Could not get user ID</div>';
            }
        })
        .catch(err => {
            console.error('Error fetching user:', err);
            messagesContainer.innerHTML = '<div class="text-center text-danger py-5">Error loading conversation</div>';
        });
        return;
    }
    
    loadConversationForUser(userId);
}

function loadConversationForUser(userId) {
    const token = getAuthToken();
    const messagesContainer = document.getElementById('ai-chat-messages');
    const emptyState = document.getElementById('ai-chat-empty-state');
    
    fetch(`/rest/v1/ai_interactions?user_id=eq.${userId}&book_id=eq.${bookId}&order=created_at.asc&limit=50`, {
        headers: {'Authorization': 'Bearer ' + token}
    })
    .then(r => r.json())
    .then(interactions => {
        messagesContainer.innerHTML = '';
        
        if (!Array.isArray(interactions) || interactions.length === 0) {
            emptyState.style.display = 'block';
            messagesContainer.appendChild(emptyState);
            return;
        }
        
        emptyState.style.display = 'none';
        
        // Display all messages in chronological order
        interactions.forEach(interaction => {
            // User message
            addChatMessage('user', interaction.question || 'Question', interaction.created_at);
            
            // AI message
            addChatMessage('ai', interaction.response || 'No response', interaction.created_at, interaction.provider);
        });
        
        // Scroll to bottom
        scrollChatToBottom();
    })
    .catch(err => {
        // Silently fail - don't show error message
        console.error('Error loading conversation history:', err);
        // Just show empty state
        if (emptyState) {
            emptyState.style.display = 'block';
            messagesContainer.appendChild(emptyState);
        }
    });
}

// Get current user ID - cached to avoid multiple API calls
let cachedUserID = null;

function getCurrentUserID() {
    // Return cached value if available
    if (cachedUserID) {
        return cachedUserID;
    }
    
    // Try to get from user object if available
    if (window.currentUser && window.currentUser.id) {
        cachedUserID = window.currentUser.id;
        return cachedUserID;
    }
    
    // Fallback: parse from token (basic decode, no verification needed for client-side)
    const token = getAuthToken();
    if (token) {
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            cachedUserID = payload.user_id || payload.sub || '';
            if (cachedUserID) {
                return cachedUserID;
            }
        } catch(e) {
            console.error('Error parsing token:', e);
        }
    }
    
    // Last resort: fetch from API (this is async, so we'll need to handle it)
    // For now, return empty and let the API call handle it
    return '';
}

// Add a chat message to the conversation
function addChatMessage(role, content, timestamp, provider = null, isHTML = false) {
    const messagesContainer = document.getElementById('ai-chat-messages');
    if (!messagesContainer) return;
    
    const emptyState = document.getElementById('ai-chat-empty-state');
    if (emptyState) {
        emptyState.style.display = 'none';
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${role}`;
    
    const bubbleDiv = document.createElement('div');
    bubbleDiv.className = `chat-bubble ${role}`;
    
    // Format timestamp
    let timeStr = '';
    if (timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        
        if (diffMins < 1) {
            timeStr = 'Just now';
        } else if (diffMins < 60) {
            timeStr = `${diffMins}m ago`;
        } else if (diffMins < 1440) {
            timeStr = `${Math.floor(diffMins / 60)}h ago`;
        } else {
            timeStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
    }
    
    let headerText = 'AI Assistant';
    if (role === 'user') {
        headerText = 'You';
    } else if (provider) {
        const providerName = provider === 'gemini' ? 'Gemini' : (provider === 'moonshot' ? 'Moonshot' : provider);
        headerText = `AI Assistant <span class="badge bg-secondary" style="font-size: 0.6rem; margin-left: 0.5rem;">${escapeHtml(providerName)}</span>`;
    }
    
    // Format content - use HTML directly if isHTML flag is set, otherwise format as markdown
    const formattedContent = isHTML ? content : formatAIResponse(content);
    
    bubbleDiv.innerHTML = `
        <div class="chat-message-header">${headerText}</div>
        <div class="chat-message-content">${formattedContent}</div>
        <div class="chat-message-time">${timeStr}</div>
    `;
    
    messageDiv.appendChild(bubbleDiv);
    messagesContainer.appendChild(messageDiv);
    
    // Update last message preview in minimized bar
    if (role === 'ai') {
        const preview = document.getElementById('ai-chat-last-message-preview');
        if (preview) {
            const textContent = content.replace(/<[^>]*>/g, '').trim();
            preview.textContent = textContent.length > 30 ? textContent.substring(0, 30) + '...' : textContent;
        }
    }
    
    // Scroll to bottom after adding message - ensure latest conversation is visible
    scrollChatToBottom();
    
    // Additional scroll after content is fully rendered (for images, HTML content)
    setTimeout(() => {
        scrollChatToBottom();
    }, 300);
}

// Show typing indicator
function showTypingIndicator() {
    const messagesContainer = document.getElementById('ai-chat-messages');
    if (!messagesContainer) return null;
    
    const emptyState = document.getElementById('ai-chat-empty-state');
    if (emptyState) {
        emptyState.style.display = 'none';
    }
    
    // Remove existing typing indicator if any
    const existingTyping = messagesContainer.querySelector('.chat-typing-indicator');
    if (existingTyping && existingTyping.closest('.chat-message')) {
        existingTyping.closest('.chat-message').remove();
    }
    
    const typingDiv = document.createElement('div');
    typingDiv.className = 'chat-message ai';
    typingDiv.innerHTML = `
        <div class="chat-bubble ai">
            <div class="chat-message-header">AI Assistant</div>
            <div class="chat-typing-indicator">
                <div class="chat-typing-dot"></div>
                <div class="chat-typing-dot"></div>
                <div class="chat-typing-dot"></div>
            </div>
        </div>
    `;
    
    messagesContainer.appendChild(typingDiv);
    scrollChatToBottom();
    
    return typingDiv;
}

// Remove typing indicator
function removeTypingIndicator() {
    const messagesContainer = document.getElementById('ai-chat-messages');
    const typingIndicator = messagesContainer.querySelector('.chat-typing-indicator');
    if (typingIndicator) {
        typingIndicator.closest('.chat-message').remove();
    }
}

// Scroll chat to bottom - ensure latest message is visible
function scrollChatToBottom() {
    const messagesContainer = document.getElementById('ai-chat-messages');
    if (!messagesContainer) return;
    
    // Use requestAnimationFrame for smoother scrolling
    requestAnimationFrame(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        // Also ensure scroll after a brief delay to handle dynamic content
        setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            // Scroll with smooth behavior to the very bottom
            const lastMessage = messagesContainer.lastElementChild;
            if (lastMessage) {
                lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
        }, 150);
    });
}

// Clear chat conversation
function clearChat() {
    // Clear chat messages
    const messagesContainer = document.getElementById('ai-chat-messages');
    const emptyState = document.getElementById('ai-chat-empty-state');
    messagesContainer.innerHTML = '';
    emptyState.style.display = 'block';
    messagesContainer.appendChild(emptyState);
    
    // Clear selected text
    clearSelection();
    
    // Clear chat input field
    const questionInput = document.getElementById('ai-question');
    if (questionInput) {
        questionInput.value = '';
        questionInput.style.height = 'auto';
        questionInput.style.height = '38px'; // Reset to default height
    }
    
    // Hide selection status indicator
    const statusDiv = document.getElementById('ai-chat-selection-status');
    if (statusDiv) {
        statusDiv.style.display = 'none';
    }
}

// Helper function to complete cut-off words at the beginning and end of text
function completeCutOffWords(text) {
    if (!text || text.trim().length === 0) return text;
    
    // Find the original source text to complete cut-off words
    // Try to find the text in the page content or chat messages
    let sourceText = '';
    
    // First, try to find in page content
    const pageContent = document.getElementById('page-content');
    if (pageContent) {
        sourceText = pageContent.textContent || '';
    }
    
    // If not found, try chat messages
    if (!sourceText || sourceText.indexOf(text.trim()) === -1) {
        const chatMessages = document.getElementById('ai-chat-messages');
        if (chatMessages) {
            sourceText = chatMessages.textContent || '';
        }
    }
    
    // If we found the text in source, complete cut-off words
    if (sourceText) {
        const trimmedText = text.trim();
        const index = sourceText.indexOf(trimmedText);
        
        if (index !== -1) {
            let start = index;
            let end = index + trimmedText.length;
            
            // Complete word at the beginning if cut off
            while (start > 0 && /\w/.test(sourceText[start - 1])) {
                start--;
            }
            
            // Complete word at the end if cut off
            while (end < sourceText.length && /\w/.test(sourceText[end])) {
                end++;
            }
            
            // If we expanded, return the expanded text
            if (start < index || end > index + trimmedText.length) {
                return sourceText.substring(start, end).trim();
            }
        }
    }
    
    // If no source found or text not found in source, just return original
    return text.trim();
}

// Extract actual text from a pre-formatted prompt
function extractTextFromPrompt(formattedText) {
    if (!formattedText) return '';
    
    // Remove common prefixes and quotes
    // Handle formats like: "Help me understand this: "text""
    // Or: 'Find misunderstood words: "text"'
    // Or: 'Visual example: "text"'
    const patterns = [
        /^Help me understand this:\s*"([^"]+)"$/i,
        /^Explain this:\s*"([^"]+)"$/i,
        /^Find misunderstood words:\s*"([^"]+)"$/i,
        /^Visual example:\s*"([^"]+)"$/i,
        /^"([^"]+)"$/,  // Just quoted text
    ];
    
    for (const pattern of patterns) {
        const match = formattedText.match(pattern);
        if (match && match[1]) {
            return match[1].trim();
        }
    }
    
    // If no pattern matches, return as-is (might already be plain text)
    return formattedText.trim();
}

// Set quick question based on type
function setQuickQuestion(type) {
    const questionInput = document.getElementById('ai-question');
    const currentText = questionInput.value.trim();
    
    let question = '';
    
    // If there's already text in the input field, extract the actual text first
    if (currentText) {
        // Extract actual text from any pre-formatted prompt
        const extractedText = extractTextFromPrompt(currentText);
        const completedText = completeCutOffWords(extractedText);
        
        switch(type) {
            case 'explain':
                question = `Explain this: "${completedText}"`;
                break;
            case 'find_misunderstood_word':
                question = `Find misunderstood words: "${completedText}"`;
                break;
            case 'visual_example':
                question = `Visual example: "${completedText}"`;
                break;
            default:
                question = completedText;
        }
    } else {
        // If no text in input, use section content as fallback
        const currentSection = currentPageSections[currentSectionIndex];
        const sectionContent = currentSection ? (currentSection.content || '').substring(0, 200) : '';
        
        switch(type) {
            case 'explain':
                question = sectionContent ? `Explain this passage: "${sectionContent.substring(0, 100)}..."` : 'Explain this section';
                break;
            case 'find_misunderstood_word':
                question = sectionContent ? `Find misunderstood words: "${sectionContent.substring(0, 100)}..."` : 'Find misunderstood words in this section';
                break;
            case 'visual_example':
                question = sectionContent ? `Visual example: "${sectionContent.substring(0, 100)}..."` : 'Show me a visual example';
                break;
            default:
                question = '';
        }
    }
    
    questionInput.value = question;
    questionInput.focus();
    questionInput.style.height = 'auto';
    questionInput.style.height = Math.min(questionInput.scrollHeight, 120) + 'px';
}

// Get prior sentence from section content
function getPriorSentence(selectedText, sectionContent) {
    if (!sectionContent || !selectedText) return '';
    
    // Find the position of selected text in section content
    const selectedIndex = sectionContent.indexOf(selectedText);
    if (selectedIndex === -1) return '';
    
    // Get text before the selected text
    const textBefore = sectionContent.substring(0, selectedIndex).trim();
    if (!textBefore) return '';
    
    // Find the last sentence before the selected text
    // Look for sentence endings: . ! ? followed by space or end of string
    const sentenceEndRegex = /[.!?]\s+/g;
    const matches = [...textBefore.matchAll(sentenceEndRegex)];
    
    if (matches.length > 0) {
        // Get the last sentence
        const lastMatch = matches[matches.length - 1];
        const lastSentenceStart = lastMatch.index + lastMatch[0].length;
        return textBefore.substring(lastSentenceStart).trim();
    } else {
        // No sentence ending found, return the last part of textBefore (up to 200 chars)
        return textBefore.substring(Math.max(0, textBefore.length - 200)).trim();
    }
}

// Extract selected text from question (for find_misunderstood_word)
function extractSelectedTextFromQuestion(question) {
    // Look for pattern: "Find misunderstood words: "text""
    const match = question.match(/Find misunderstood words:\s*"([^"]+)"/i);
    if (match && match[1]) {
        return match[1];
    }
    // Also check for pattern without quotes
    const match2 = question.match(/Find misunderstood words:\s*(.+)/i);
    if (match2 && match2[1]) {
        return match2[1].trim();
    }
    return null;
}

// Extract text for visual example
function extractTextForVisualExample(question) {
    // Look for pattern: "Visual example: "text""
    const match = question.match(/Visual example:\s*"([^"]+)"/i);
    if (match && match[1]) {
        return match[1];
    }
    // Also check for pattern without quotes
    const match2 = question.match(/Visual example:\s*(.+)/i);
    if (match2 && match2[1]) {
        return match2[1].trim();
    }
    return null;
}

// Randomly select and highlight words from selected text (no AI needed)
// Find misunderstood words using AI analysis
function findMisunderstoodWordsWithAI() {
    // Get selected text from the input or from the page
    const questionInput = document.getElementById('ai-question');
    let selectedText = '';
    
    // If no text in input, try to get from page selection or global selectedText
    if (!questionInput || !questionInput.value.trim()) {
        // Check global selectedText variable (from selection mode)
        if (typeof window.selectedText !== 'undefined' && window.selectedText && window.selectedText.trim()) {
            selectedText = window.selectedText.trim();
        } else {
            // Try browser selection
            const selection = window.getSelection();
            if (selection && selection.toString().trim()) {
                selectedText = selection.toString().trim();
            }
        }
    } else {
        selectedText = questionInput.value.trim();
    }
    
    // If still no text, try to get from current section content
    if (!selectedText && typeof currentPageSections !== 'undefined' && currentPageSections && currentPageSections[currentSectionIndex]) {
        const currentSection = currentPageSections[currentSectionIndex];
        if (currentSection && currentSection.content) {
            // Use first 200 characters of current section as fallback
            selectedText = currentSection.content.substring(0, 200).trim();
        }
    }
    
    if (!selectedText) {
        // Show message to select text first
        addChatMessage('ai', 'Please select the text you want to check, or type it in the input field, then click "Find the misunderstood word".', new Date().toISOString());
        return;
    }
    
    console.log('Selected text for AI word analysis:', selectedText);
    
    // Set the input value with the proper format for AI
    if (questionInput) {
        questionInput.value = `Find misunderstood words: "${selectedText}"`;
    }
    
    // Call askAI with the find_misunderstood_word interaction type
    // This will be handled by askAI() which detects the interaction type
    askAI();
}

// Highlight words in page (reusable function)
function highlightWordsInPage(words) {
    if (!words || words.length === 0) {
        console.error('No words provided for highlighting');
        return false;
    }
    
    console.log('Highlighting words in page:', words);
    
    const pageContent = document.getElementById('page-content');
    if (!pageContent) {
        console.error('Page content element not found');
        return false;
    }
    
    // Store highlighted words for later removal
    if (!window.misunderstoodWordHighlights) {
        window.misunderstoodWordHighlights = [];
    }
    
    // Clear any existing highlights first
    if (window.misunderstoodWordHighlights.length > 0) {
        clearMisunderstoodWordHighlights();
    }
    
    // Use TreeWalker to find and replace only text nodes (not HTML attributes)
    const walker = document.createTreeWalker(
        pageContent,
        NodeFilter.SHOW_TEXT,
        {
            acceptNode: function(node) {
                // Skip text nodes inside script, style, or already highlighted words
                const parent = node.parentNode;
                if (!parent) return NodeFilter.FILTER_REJECT;
                if (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE') {
                    return NodeFilter.FILTER_REJECT;
                }
                // Skip if already inside any word-highlight span (to preserve existing dictionary functionality)
                if (parent.classList && (parent.classList.contains('misunderstood-word-highlight') || parent.classList.contains('word-highlight'))) {
                    return NodeFilter.FILTER_REJECT;
                }
                // Also check if any ancestor is a word-highlight span
                let current = parent;
                while (current && current !== pageContent) {
                    if (current.classList && (current.classList.contains('word-highlight') || current.classList.contains('misunderstood-word-highlight'))) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    current = current.parentNode;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        },
        false
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
        textNodes.push(node);
    }
    
    let highlightedCount = 0;
    
    // Process each word
    words.forEach(word => {
        const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const wordRegex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
        
        // Process each text node
        textNodes.forEach(textNode => {
            // Double-check: skip if this text node is inside a word-highlight span
            let current = textNode.parentNode;
            let insideWordHighlight = false;
            while (current && current !== pageContent) {
                if (current.classList && (current.classList.contains('word-highlight') || current.classList.contains('misunderstood-word-highlight'))) {
                    insideWordHighlight = true;
                    break;
                }
                current = current.parentNode;
            }
            if (insideWordHighlight) {
                return; // Skip this text node
            }
            
            const text = textNode.textContent;
            if (wordRegex.test(text)) {
                const parent = textNode.parentNode;
                
                // Final safety check: don't process if parent is a word-highlight
                if (parent && parent.classList && parent.classList.contains('word-highlight')) {
                    return; // Skip
                }
                
                const parts = text.split(wordRegex);
                const matches = text.match(wordRegex) || [];
                
                if (matches.length > 0 && parts.length > 1) {
                    const fragment = document.createDocumentFragment();
                    
                    for (let i = 0; i < parts.length; i++) {
                        if (parts[i]) {
                            fragment.appendChild(document.createTextNode(parts[i]));
                        }
                        if (i < matches.length) {
                            const highlightSpan = document.createElement('span');
                            highlightSpan.className = 'word-highlight misunderstood-word-highlight';
                            highlightSpan.style.backgroundColor = '#fff3cd';
                            highlightSpan.style.padding = '2px 4px';
                            highlightSpan.style.borderRadius = '3px';
                            highlightSpan.style.cursor = 'pointer';
                            highlightSpan.style.textDecoration = 'underline';
                            highlightSpan.style.textDecorationStyle = 'dotted';
                            highlightSpan.textContent = matches[i];
                            
                            // Normalize word the same way as regular word highlights
                            const cleanWord = matches[i].replace(/[.,!?;:()\[\]{}"']/g, '').toLowerCase();
                            
                            // Make clickable for dictionary lookup
                            const escapedCleanWord = escapeHtml(cleanWord);
                            highlightSpan.setAttribute('onclick', `lookupWordFromText('${escapedCleanWord}', event)`);
                            highlightSpan.setAttribute('data-word', escapedCleanWord);
                            
                            fragment.appendChild(highlightSpan);
                            window.misunderstoodWordHighlights.push(highlightSpan);
                            highlightedCount++;
                            console.log(`Highlighted word "${matches[i]}" (clean: "${cleanWord}")`);
                        }
                    }
                    
                    // Replace the text node with the fragment
                    try {
                        parent.replaceChild(fragment, textNode);
                    } catch (e) {
                        console.error('Error replacing text node:', e);
                    }
                }
            }
        });
        
        if (!wordFoundInPage) {
            console.warn(`Word "${word}" was not found in any text node on the page`);
        }
    });
    
    console.log('Total words highlighted:', highlightedCount);
    return highlightedCount > 0;
}

// Parse misunderstood words response and highlight them in the page text (OLD - kept for backwards compatibility)
function parseAndHighlightMisunderstoodWordsInPage(responseText, selectedText) {
    console.log('Parsing AI response for misunderstood words. Raw response:', responseText);
    
    // Clean up the response - remove common prefixes and suffixes the AI might add
    let cleanedText = responseText.trim();
    
    // Remove common prefixes the AI might add
    cleanedText = cleanedText.replace(/^(here are the words?|the words? (are|might be)|words?:?|misunderstood words?:?)\s*/i, '');
    
    // Remove any leading/trailing punctuation or quotes
    cleanedText = cleanedText.replace(/^["'`\[\]()]+|["'`\[\]()]+$/g, '');
    
    // Remove any trailing explanations or additional text (look for common patterns)
    // Stop at common phrases like "These words", "Remember", etc.
    const stopPatterns = [
        /(\n|\.)\s*(These? words?|Remember|Note:|Tip:|Important:)/i,
        /\n\n/  // Double newline usually indicates additional text
    ];
    
    for (const pattern of stopPatterns) {
        const match = cleanedText.match(pattern);
        if (match) {
            cleanedText = cleanedText.substring(0, match.index).trim();
        }
    }
    
    console.log('Cleaned text after prefix/suffix removal:', cleanedText);
    
    // Parse comma-separated word list from cleaned AI response
    let words = cleanedText
        .split(',')
        .map(w => w.trim())
        .filter(w => w.length > 0 && w.length < 50) // Filter out very long strings (likely not words)
        .map(w => {
            // Remove any remaining quotes or punctuation from individual words
            return w.replace(/^["'`\[\]()]+|["'`\[\]()]+$/g, '').trim();
        })
        .filter(w => w.length > 0 && /^[a-zA-Z'-]+$/.test(w)) // Only keep words with letters, hyphens, apostrophes
        .slice(0, 8); // Maximum 8 words
    
    console.log('Words after comma split:', words);
    
    // If we still have no words, try splitting by newlines or other delimiters
    if (words.length === 0) {
        console.warn('No words found after comma split, trying alternative parsing...');
        // Try splitting by newlines
        words = cleanedText
            .split(/\n|\.|;|:/)
            .map(w => w.trim())
            .filter(w => w.length > 0 && w.length < 50)
            .map(w => w.replace(/^["'`\[\]()]+|["'`\[\]()]+$/g, '').trim())
            .filter(w => w.length > 0 && /^[a-zA-Z'-]+$/.test(w))
            .slice(0, 8);
        console.log('Words after alternative parsing:', words);
    }
    
    if (words.length === 0) {
        console.error('No words found in AI response after parsing. Raw response:', responseText);
        console.error('Cleaned text:', cleanedText);
        return false;
    }
    
    console.log('Successfully parsed words:', words);
    console.log('Highlighting misunderstood words in page:', words);
    
    const pageContent = document.getElementById('page-content');
    if (!pageContent) {
        console.error('Page content element not found');
        return false;
    }
    
    // Log a sample of page content for debugging
    const pageTextSample = pageContent.textContent.substring(0, 200);
    console.log('Page content sample (first 200 chars):', pageTextSample);
    
    // Store highlighted words for later removal
    if (!window.misunderstoodWordHighlights) {
        window.misunderstoodWordHighlights = [];
    }
    
    // Clear any existing highlights first
    if (window.misunderstoodWordHighlights.length > 0) {
        clearMisunderstoodWordHighlights();
    }
    
    // Use TreeWalker to find and replace only text nodes (not HTML attributes)
    const walker = document.createTreeWalker(
        pageContent,
        NodeFilter.SHOW_TEXT,
        {
            acceptNode: function(node) {
                // Skip text nodes inside script, style, or already highlighted words
                const parent = node.parentNode;
                if (!parent) return NodeFilter.FILTER_REJECT;
                if (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE') {
                    return NodeFilter.FILTER_REJECT;
                }
                // Skip if already inside any word-highlight span (to preserve existing dictionary functionality)
                if (parent.classList && (parent.classList.contains('misunderstood-word-highlight') || parent.classList.contains('word-highlight'))) {
                    return NodeFilter.FILTER_REJECT;
                }
                // Also check if any ancestor is a word-highlight span
                let current = parent;
                while (current && current !== pageContent) {
                    if (current.classList && (current.classList.contains('word-highlight') || current.classList.contains('misunderstood-word-highlight'))) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    current = current.parentNode;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        },
        false
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
        textNodes.push(node);
    }
    
    let highlightedCount = 0;
    
    // Process each word - normalize to lowercase for matching but preserve original case for display
    words.forEach(word => {
        // Normalize word to lowercase for matching (but we'll use original case from page)
        const normalizedWord = word.toLowerCase();
        const escapedWord = normalizedWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        // Use word boundary regex that's case-insensitive
        const wordRegex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
        
        console.log(`Searching for word: "${word}" (normalized: "${normalizedWord}") with regex: ${wordRegex}`);
        let wordFoundInPage = false;
        
        // Process each text node
        textNodes.forEach(textNode => {
            // Double-check: skip if this text node is inside a word-highlight span
            let current = textNode.parentNode;
            let insideWordHighlight = false;
            while (current && current !== pageContent) {
                if (current.classList && (current.classList.contains('word-highlight') || current.classList.contains('misunderstood-word-highlight'))) {
                    insideWordHighlight = true;
                    break;
                }
                current = current.parentNode;
            }
            if (insideWordHighlight) {
                return; // Skip this text node
            }
            
            const text = textNode.textContent;
            // Reset regex lastIndex to avoid issues with test() side effects
            wordRegex.lastIndex = 0;
            // Test if the word appears in this text node (case-insensitive)
            if (wordRegex.test(text)) {
                wordFoundInPage = true;
                const parent = textNode.parentNode;
                
                // Final safety check: don't process if parent is a word-highlight
                if (parent && parent.classList && parent.classList.contains('word-highlight')) {
                    return; // Skip
                }
                
                // Reset regex again before split/match
                wordRegex.lastIndex = 0;
                // Split and match, preserving original case from the page
                const parts = text.split(wordRegex);
                wordRegex.lastIndex = 0;
                const matches = text.match(wordRegex) || [];
                
                console.log(`Found "${word}" in text node. Matches:`, matches, 'Text sample:', text.substring(0, 50));
                
                if (matches.length > 0 && parts.length > 1) {
                    const fragment = document.createDocumentFragment();
                    
                    for (let i = 0; i < parts.length; i++) {
                        if (parts[i]) {
                            fragment.appendChild(document.createTextNode(parts[i]));
                        }
                        if (i < matches.length) {
                            const highlightSpan = document.createElement('span');
                            highlightSpan.className = 'word-highlight misunderstood-word-highlight';
                            highlightSpan.style.backgroundColor = '#fff3cd';
                            highlightSpan.style.padding = '2px 4px';
                            highlightSpan.style.borderRadius = '3px';
                            highlightSpan.style.cursor = 'pointer';
                            highlightSpan.style.textDecoration = 'underline';
                            highlightSpan.style.textDecorationStyle = 'dotted';
                            // Use the matched word from the page (preserves original case)
                            highlightSpan.textContent = matches[i];
                            
                            // Normalize word the same way as regular word highlights
                            // Remove punctuation and convert to lowercase (same as formatTextWithWordHighlights)
                            const cleanWord = matches[i].replace(/[.,!?;:()\[\]{}"']/g, '').toLowerCase();
                            
                            // Make clickable for dictionary lookup
                            // Use the same pattern as existing word-highlight elements (inline onclick for compatibility)
                            const escapedCleanWord = escapeHtml(cleanWord);
                            highlightSpan.setAttribute('onclick', `lookupWordFromText('${escapedCleanWord}', event)`);
                            highlightSpan.setAttribute('data-word', escapedCleanWord);
                            
                            fragment.appendChild(highlightSpan);
                            window.misunderstoodWordHighlights.push(highlightSpan);
                            highlightedCount++;
                            console.log(`Highlighted word "${matches[i]}" (clean: "${cleanWord}")`);
                        }
                    }
                    
                    // Replace the text node with the fragment
                    try {
                        parent.replaceChild(fragment, textNode);
                    } catch (e) {
                        console.error('Error replacing text node:', e);
                    }
                }
            }
        });
        
        if (!wordFoundInPage) {
            console.warn(`Word "${word}" was not found in any text node on the page`);
        }
    });
    
    // DON'T normalize - it can break inline onclick handlers on word-highlight spans
    // pageContent.normalize();
    
    console.log('Highlighting complete. Total words highlighted:', highlightedCount);
    
    if (highlightedCount === 0) {
        console.warn('No words were highlighted. Words to highlight were:', words);
        console.warn('This might mean the words are not found in the page content, or they are already inside highlighted spans.');
    }
    
    return highlightedCount > 0;
}

// Clear misunderstood word highlights
function clearMisunderstoodWordHighlights() {
    if (!window.misunderstoodWordHighlights || window.misunderstoodWordHighlights.length === 0) {
        return;
    }
    
    // Remove highlights by replacing span with just the text
    window.misunderstoodWordHighlights.forEach(span => {
        const textNode = document.createTextNode(span.textContent);
        span.parentNode.replaceChild(textNode, span);
    });
    
    // Clear the array
    window.misunderstoodWordHighlights = [];
    
    // Normalize the page content to merge adjacent text nodes
    const pageContent = document.getElementById('page-content');
    if (pageContent) {
        pageContent.normalize();
    }
}

// Ask AI for help (chat interface version)
function askAI() {
    const questionInput = document.getElementById('ai-question');
    const question = questionInput.value.trim();
    
    if (!question) {
        alert('Please enter a question first.');
        return;
    }
    
    const token = getAuthToken();
    if (!token) {
        alert('Please log in to use AI Help.');
        window.location.href = '/login';
        return;
    }
    
    // Detect interaction type from question
    let interactionType = 'chat';
    let processedQuestion = question;
    
    if (question.toLowerCase().startsWith('find misunderstood words:') || question.toLowerCase().includes('find misunderstood')) {
        // Use AI to identify misunderstood words
        interactionType = 'find_misunderstood_word';
        // Extract selected text
        const selectedText = extractSelectedTextFromQuestion(question);
        if (selectedText) {
            processedQuestion = selectedText;
        }
        // Continue with AI call (don't return early)
    } else if (question.toLowerCase().startsWith('visual example:')) {
        interactionType = 'visual_example';
        // Extract text for visual example
        const visualText = extractTextForVisualExample(question);
        if (visualText) {
            processedQuestion = visualText;
        }
    } else if (question.toLowerCase().startsWith('explain this:')) {
        interactionType = 'explain';
        // Extract text after "Explain this:"
        const match = question.match(/explain this:\s*"([^"]+)"/i) || question.match(/explain this:\s*(.+)/i);
        if (match && match[1]) {
            processedQuestion = match[1].trim();
        }
    }
    
    // Get current section context
    const currentSection = currentPageSections[currentSectionIndex];
    const fullSectionContent = currentSection ? (currentSection.content || '') : '';
    const sectionContent = fullSectionContent.substring(0, 500);
    const sectionID = currentSection ? currentSection.id : null;
    
    // Prepare context string
    let context = `You are reading page ${currentPage}, section ${currentSectionIndex + 1} of Alice's Adventures in Wonderland.`;
    
    // For find_misunderstood_word, include prior sentence
    if (interactionType === 'find_misunderstood_word' && processedQuestion) {
        const priorSentence = getPriorSentence(processedQuestion, fullSectionContent);
        if (priorSentence) {
            context += `\n\nPrior sentence (for context): "${priorSentence}"`;
        }
        if (sectionContent) {
            context += `\n\nCurrent section text (for context): ${sectionContent}...`;
        }
    } else if (sectionContent) {
        context += `\n\nCurrent section text (for context): ${sectionContent}...`;
    }
    
    // Add user message to chat immediately
    const timestamp = new Date().toISOString();
    addChatMessage('user', question, timestamp);
    
    // Clear input and reset height
    questionInput.value = '';
    questionInput.style.height = 'auto';
    questionInput.style.height = '38px'; // Reset to default height
    
    // Show typing indicator
    const typingIndicator = showTypingIndicator();
    
    // Update button state
    const askButton = document.getElementById('ai-ask-button');
    const loadingSpinner = document.getElementById('ai-loading-spinner');
    const sendText = document.getElementById('ai-send-text');
    
    askButton.disabled = true;
    loadingSpinner.classList.remove('d-none');
    sendText.textContent = 'Sending...';
    
    // Call AI API
    fetch('/api/ai/ask', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
            book_id: bookId,
            interaction_type: interactionType,
            question: processedQuestion,
            section_id: sectionID,
            context: context
        })
    })
    .then(async res => {
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`HTTP ${res.status}: ${errorText}`);
        }
        return res.json();
    })
    .then(data => {
        // Remove typing indicator
        removeTypingIndicator();
        
        // Process AI response
        let responseText = data.response || 'No response from AI.';
        const provider = data.provider || 'unknown';
        const responseTime = data.created_at || new Date().toISOString();
        let isHTML = false;
        
        // For find_misunderstood_word, parse AI response and highlight words in page
        if (interactionType === 'find_misunderstood_word' && processedQuestion) {
            console.log('Processing find_misunderstood_word AI response. AI returned:', responseText);
            console.log('Original question/selected text:', processedQuestion);
            
            // Parse words from AI response and highlight them in the page content
            const highlighted = parseAndHighlightMisunderstoodWordsInPage(responseText, processedQuestion);
            
            // Show simple message in chat
            if (highlighted) {
                responseText = 'I will help you to locate what word(s) they might be misunderstood. Please check the words highlighted in the text.';
                // Add "understood now!" button
                responseText += `<div class="mt-3">
                    <button class="btn btn-primary btn-sm" onclick="clearMisunderstoodWordHighlights()">
                        ‚úì Understood now!
                    </button>
                </div>`;
                isHTML = true; // Contains HTML button
            } else {
                // More helpful error message
                const parsedWords = responseText.split(',').map(w => w.trim()).filter(w => w.length > 0);
                if (parsedWords.length > 0) {
                    responseText = `I found these words in the AI response: ${parsedWords.join(', ')}. However, I couldn't find them in the page content to highlight. This might mean the selected text doesn't match the current page, or the words are formatted differently. Please try selecting the text directly from the page.`;
                } else {
                    responseText = 'I tried to find misunderstood words, but couldn\'t parse the AI response. The AI response was: "' + escapeHtml(responseText.substring(0, 100)) + '". Please try again.';
                }
                console.error('Failed to highlight words. AI response was:', responseText);
                console.error('Parsed words attempt:', parsedWords);
            }
        }
        
        // For visual_example, generate image from the AI's prompt
        if (interactionType === 'visual_example') {
            // The AI response should be an image generation prompt
            const imagePrompt = responseText.trim();
            // Generate image (without showing the technical prompt to the user)
            generateAndDisplayImage(imagePrompt, responseTime, provider);
            // Show user-friendly message without technical details
            addChatMessage('ai', `<p><strong>üñºÔ∏è Generating visual example...</strong></p>`, responseTime, provider, true);
        } else {
            addChatMessage('ai', responseText, responseTime, provider, isHTML);
        }
        
        // Track activity
        trackActivity('AI_HELP', {
            interaction_type: interactionType,
            question: question.substring(0, 100)
        });
    })
    .catch(err => {
        console.error('Error asking AI:', err);
        
        // Remove typing indicator
        removeTypingIndicator();
        
        // Show error message in chat
        let errorMsg = 'Failed to get AI response. ';
        
        if (err.message.includes('503') || err.message.includes('Service Unavailable')) {
            errorMsg += 'AI service is currently unavailable. Please try again later.';
        } else if (err.message.includes('401') || err.message.includes('Unauthorized')) {
            errorMsg += 'Authentication failed. Please log in again.';
        } else if (err.message.includes('not configured')) {
            errorMsg += 'AI service is not configured. Please contact support.';
        } else {
            errorMsg += `Error: ${err.message}`;
        }
        
        addChatMessage('ai', errorMsg, new Date().toISOString());
    })
    .finally(() => {
        // Reset button state
        askButton.disabled = false;
        loadingSpinner.classList.add('d-none');
        sendText.textContent = 'Send';
        
        // Refocus input
        questionInput.focus();
    });
}

// Generate and display image from prompt
function generateAndDisplayImage(imagePrompt, timestamp, provider) {
    const token = getAuthToken();
    if (!token) {
        addChatMessage('ai', 'Error: Please log in to generate images.', new Date().toISOString());
        return;
    }

    // Add a placeholder message showing image is being generated
    const placeholderId = 'image-placeholder-' + Date.now();
    const placeholderHTML = `
        <div id="${placeholderId}" class="image-generation-placeholder">
            <p><strong>üñºÔ∏è Generating image...</strong></p>
            <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="text-muted small mt-2">This may take a few moments</p>
        </div>
    `;
    addChatMessage('ai', placeholderHTML, timestamp, provider, true);

    // Submit image generation request
    fetch('/api/ai/generate-image', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
            prompt: imagePrompt,
            aspect_ratio: 'square',
            // Model will be determined by the backend based on configured provider
            resolution: '1k' // Light image as requested
        })
    })
    .then(async res => {
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`HTTP ${res.status}: ${errorText}`);
        }
        return res.json();
    })
    .then(data => {
        // Check if image is already available (synchronous provider like DeepAI)
        if (data.status === 'completed' && data.image_url) {
            // Image is ready immediately - display it
            const imageHTML = `
                <div class="generated-image-container mt-2">
                    <p><strong>‚úÖ Visual Example Generated:</strong></p>
                    <img src="${escapeHtml(data.image_url)}" 
                         alt="Generated visual example" 
                         class="generated-image img-fluid rounded border"
                         style="max-width: 100%; height: auto; max-height: 500px; cursor: pointer;"
                         onclick="window.open(this.src, '_blank')"
                         title="Click to view full size">
                    <p class="text-muted small mt-2">Click image to view full size</p>
                </div>
            `;
            updateImagePlaceholder(placeholderId, imageHTML, timestamp, provider);
            return;
        }

        // For async providers (like Freepik), poll for status
        const taskID = data.task_id;
        if (!taskID) {
            throw new Error('No task ID returned from image generation service');
        }

        // Poll for image status (async providers)
        pollImageStatus(taskID, 'mystic', placeholderId, timestamp, provider);
    })
    .catch(err => {
        console.error('Error generating image:', err);
        updateImagePlaceholder(placeholderId, `<p class="text-danger">Failed to generate image: ${escapeHtml(err.message)}</p>`, timestamp, provider);
    });
}

// Poll image generation status
function pollImageStatus(taskID, model, placeholderId, timestamp, provider) {
    const token = getAuthToken();
    if (!token) return;

    const maxAttempts = 60; // Max 2 minutes (2 seconds * 60)
    let attempt = 0;

    const poll = () => {
        if (attempt >= maxAttempts) {
            updateImagePlaceholder(placeholderId, '<p class="text-warning">Image generation timed out. Please try again.</p>', timestamp, provider);
            return;
        }

        attempt++;

        fetch(`/api/ai/image-status?task_id=${encodeURIComponent(taskID)}&model=${encodeURIComponent(model)}`, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token
            }
        })
        .then(async res => {
            if (!res.ok) {
                if (res.status === 404) {
                    throw new Error('Image task not found');
                }
                const errorText = await res.text();
                throw new Error(`HTTP ${res.status}: ${errorText}`);
            }
            return res.json();
        })
        .then(data => {
            const status = data.status;

            if (status === 'completed' && data.image_url) {
                // Image is ready!
                const imageHTML = `
                    <div class="generated-image-container mt-2">
                        <p><strong>‚úÖ Visual Example Generated:</strong></p>
                        <img src="${escapeHtml(data.image_url)}" 
                             alt="Generated visual example" 
                             class="generated-image img-fluid rounded border"
                             style="max-width: 100%; height: auto; max-height: 500px; cursor: pointer;"
                             onclick="window.open(this.src, '_blank')"
                             title="Click to view full size">
                        <p class="text-muted small mt-2">Click image to view full size</p>
                    </div>
                `;
                updateImagePlaceholder(placeholderId, imageHTML, timestamp, provider);
            } else if (status === 'failed') {
                const errorMsg = data.error || 'Image generation failed';
                updateImagePlaceholder(placeholderId, `<p class="text-danger">Image generation failed: ${escapeHtml(errorMsg)}</p>`, timestamp, provider);
            } else if (status === 'pending' || status === 'processing') {
                // Still processing, poll again after 2 seconds
                setTimeout(poll, 2000);
            } else {
                // Unknown status, continue polling
                setTimeout(poll, 2000);
            }
        })
        .catch(err => {
            console.error('Error checking image status:', err);
            if (err.message.includes('not found')) {
                updateImagePlaceholder(placeholderId, '<p class="text-danger">Image task not found. Please try again.</p>', timestamp, provider);
            } else {
                // Retry after 2 seconds
                setTimeout(poll, 2000);
            }
        });
    };

    // Start polling after 2 seconds
    setTimeout(poll, 2000);
}

// Update image placeholder with final content
function updateImagePlaceholder(placeholderId, content, timestamp, provider) {
    const placeholder = document.getElementById(placeholderId);
    if (placeholder) {
        placeholder.innerHTML = content;
    } else {
        // If placeholder not found, add as new message
        addChatMessage('ai', content, timestamp, provider, true);
    }
}

// Text Selection Tool Functions
let textSelectionModeActive = false;
let selectionToolbarAlwaysOn = true; // show AI spark on normal text selection
let selectedText = '';
let selectedRange = null;
let aiChatSelectionModeActive = false; // Track if selection mode is active from AI chat

// Toggle text selection mode (for AI chat modal)
function toggleAIChatSelectionMode() {
    aiChatSelectionModeActive = !aiChatSelectionModeActive;
    textSelectionModeActive = aiChatSelectionModeActive || selectionToolbarAlwaysOn;
    
    const btn = document.getElementById('ai-chat-pencil-btn');
    const icon = document.getElementById('ai-chat-pencil-icon');
    const statusText = document.getElementById('ai-chat-selection-status');
    const statusDiv = document.getElementById('ai-chat-selection-status');
    const pageContent = document.getElementById('page-content');
    const readingContainer = document.getElementById('reading-container');
    const modal = document.getElementById('aiHelpModal');
    
    if (aiChatSelectionModeActive) {
        // Enable selection mode
        btn.classList.add('active', 'btn-primary');
        btn.classList.remove('btn-outline-secondary');
        icon.textContent = '‚úì';
        
        if (statusDiv) {
            statusDiv.style.display = 'block';
        }
        
        if (pageContent) {
            pageContent.classList.add('text-selection-active');
            readingContainer.classList.add('text-selection-active');
        }
        
        // Make modal backdrop and dialog allow interaction with page behind it
        // Bootstrap creates backdrop dynamically, so we need to wait for it
        const adjustBackdrop = () => {
            const backdrop = document.querySelector('.modal-backdrop');
            const modalDialog = document.getElementById('aiHelpModalDialog');
            const modal = document.getElementById('aiHelpModal');
            
            if (backdrop) {
                backdrop.style.pointerEvents = 'none';
                backdrop.style.backgroundColor = 'transparent'; // No grey backdrop - completely transparent
            }
            
            // Make modal element itself allow pointer events through
            if (modal) {
                modal.style.pointerEvents = 'none';
            }
            
            // Make modal dialog allow pointer events to pass through
            if (modalDialog) {
                modalDialog.style.pointerEvents = 'none';
            }
            
            const modalContent = modalDialog ? modalDialog.querySelector('.modal-content') : null;
            if (modalContent) {
                // Make modal content allow pointer events through by default
                modalContent.style.pointerEvents = 'none';
                
                // But allow interaction with specific interactive elements
                const interactiveElements = modalContent.querySelectorAll(
                    'button, textarea, input, #ai-chat-messages, .chat-message, .chat-bubble, .modal-header, .modal-body, .border-top'
                );
                interactiveElements.forEach(el => {
                    el.style.pointerEvents = 'auto';
                });
                
                // Also make sure the entire chat messages container is interactive
                const chatMessages = document.getElementById('ai-chat-messages');
                if (chatMessages) {
                    chatMessages.style.pointerEvents = 'auto';
                }
            }
            
            // If backdrop or dialog don't exist yet, try again
            if (!backdrop || !modalDialog) {
                setTimeout(adjustBackdrop, 50);
            }
        };
        adjustBackdrop();
        
        // Enable selection on the page
        enableTextSelection();
        
        // Add global Enter key handler to copy selected text
        document.addEventListener('keydown', handleGlobalEnterKey, true);
    } else {
        // Disable selection mode
        btn.classList.remove('active', 'btn-primary');
        btn.classList.add('btn-outline-secondary');
        icon.textContent = '‚úèÔ∏è';
        
        if (statusDiv) {
            statusDiv.style.display = 'none';
        }
        
        if (pageContent) {
            pageContent.classList.remove('text-selection-active');
            readingContainer.classList.remove('text-selection-active');
        }
        
        // Restore modal backdrop and dialog
        setTimeout(() => {
            const backdrop = document.querySelector('.modal-backdrop');
            const modalDialog = document.getElementById('aiHelpModalDialog');
            const modal = document.getElementById('aiHelpModal');
            const modalContent = modalDialog ? modalDialog.querySelector('.modal-content') : null;
            
            if (backdrop) {
                backdrop.style.pointerEvents = 'auto';
                backdrop.style.backgroundColor = ''; // Reset to default
            }
            
            if (modal) {
                modal.style.pointerEvents = 'auto';
            }
            
            if (modalDialog) {
                modalDialog.style.pointerEvents = 'auto';
            }
            
            if (modalContent) {
                modalContent.style.pointerEvents = 'auto';
                
                // Reset all interactive elements to default
                const interactiveElements = modalContent.querySelectorAll(
                    'button, textarea, input, #ai-chat-messages, .chat-message, .chat-bubble, .modal-header, .modal-body, .border-top'
                );
                interactiveElements.forEach(el => {
                    el.style.pointerEvents = '';
                });
            }
        }, 100);
        
        clearSelection();
        disableTextSelection();
        
        // Remove global Enter key handler
        document.removeEventListener('keydown', handleGlobalEnterKey, true);
    }
}

// Handle global Enter key press (when selection mode is active)
function handleGlobalEnterKey(e) {
    // Only handle if selection mode is active and Enter is pressed (not in input fields)
    if (aiChatSelectionModeActive && e.key === 'Enter' && selectedText) {
        const target = e.target;
        // Don't interfere if user is typing in an input/textarea
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
            // If it's the chat input, handle it in handleChatInputKeydown
            return;
        }
        
        // Copy selected text to chat input
        e.preventDefault();
        e.stopPropagation();
        copySelectedTextToChatInput();
    }
}

// Toggle text selection mode (old function - kept for backwards compatibility if needed)
function toggleTextSelection() {
    // This function is no longer used, but keeping it for reference
    toggleAIChatSelectionMode();
}

// Draggable Pencil Button
let isDraggingPencil = false;
let pencilDragStartX = 0;
let pencilDragStartY = 0;
let pencilStartX = 0;
let pencilStartY = 0;
let pencilDragThreshold = 5; // pixels to move before considering it a drag
let pencilTouchStartTime = 0; // Track touch start time for tap detection

// Initialize draggable pencil button
let pencilInitAttempts = 0;
const MAX_PENCIL_INIT_ATTEMPTS = 10;

function initDraggablePencil() {
    try {
        const btn = document.getElementById('text-selection-btn');
        if (!btn) {
            // Button not found yet, try again later (but limit attempts)
            pencilInitAttempts++;
            if (pencilInitAttempts < MAX_PENCIL_INIT_ATTEMPTS) {
                setTimeout(initDraggablePencil, 100);
            }
            return;
        }
        
        // Reset counter on success
        pencilInitAttempts = 0;
        
        // Load saved position from localStorage
        try {
            const savedPos = localStorage.getItem('pencilButtonPosition');
            if (savedPos) {
                const pos = JSON.parse(savedPos);
                if (pos && (pos.top !== undefined || pos.left !== undefined)) {
                    if (pos.top !== undefined) btn.style.top = pos.top;
                    if (pos.left !== undefined) {
                        btn.style.left = pos.left;
                        btn.style.right = 'auto';
                    }
                    if (pos.right !== undefined && !pos.left) {
                        btn.style.right = pos.right;
                        btn.style.left = 'auto';
                    }
                    if (pos.bottom !== undefined) btn.style.bottom = pos.bottom;
                }
            }
        } catch (e) {
            console.log('Error loading pencil position:', e);
        }
        
        // Mouse events for desktop
        btn.addEventListener('mousedown', startDragPencil);
        
        // Touch events for mobile (tap to toggle, drag to move)
        btn.addEventListener('touchstart', startDragPencilTouch, { passive: false });
        
        // Click handler for desktop (only if not dragging)
        btn.addEventListener('click', handlePencilClick);
    } catch (e) {
        console.error('Error initializing draggable pencil:', e);
    }
}

// Start dragging (mouse)
function startDragPencil(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const btn = document.getElementById('text-selection-btn');
    if (!btn) return;
    
    isDraggingPencil = false;
    pencilDragStartX = e.clientX;
    pencilDragStartY = e.clientY;
    
    const rect = btn.getBoundingClientRect();
    pencilStartX = rect.left;
    pencilStartY = rect.top;
    
    btn.classList.add('dragging');
    
    document.addEventListener('mousemove', dragPencil);
    document.addEventListener('mouseup', stopDragPencil);
}

// Start dragging (touch)
function startDragPencilTouch(e) {
    const btn = document.getElementById('text-selection-btn');
    if (!btn) return;
    
    // Don't prevent default immediately - we need to detect tap vs drag
    isDraggingPencil = false;
    pencilTouchStartTime = Date.now();
    const touch = e.touches[0];
    if (!touch) return;
    
    pencilDragStartX = touch.clientX;
    pencilDragStartY = touch.clientY;
    
    const rect = btn.getBoundingClientRect();
    pencilStartX = rect.left;
    pencilStartY = rect.top;
    
    document.addEventListener('touchmove', handlePencilTouchMove, { passive: false });
    document.addEventListener('touchend', stopDragPencilTouch, { once: true });
}

// Handle touch move to detect drag
function handlePencilTouchMove(e) {
    const btn = document.getElementById('text-selection-btn');
    if (!btn) return;
    
    const touch = e.touches[0];
    const deltaX = Math.abs(touch.clientX - pencilDragStartX);
    const deltaY = Math.abs(touch.clientY - pencilDragStartY);
    
    // If moved more than threshold, it's a drag
    if (deltaX > pencilDragThreshold || deltaY > pencilDragThreshold) {
        isDraggingPencil = true;
        e.preventDefault();
        btn.classList.add('dragging');
        // Switch to drag handler
        document.removeEventListener('touchmove', handlePencilTouchMove);
        document.addEventListener('touchmove', dragPencilTouch, { passive: false });
        dragPencilTouch(e); // Start dragging
    }
}

// Drag (mouse)
function dragPencil(e) {
    if (!isDraggingPencil) {
        const deltaX = Math.abs(e.clientX - pencilDragStartX);
        const deltaY = Math.abs(e.clientY - pencilDragStartY);
        
        // Only start dragging if moved more than threshold
        if (deltaX > pencilDragThreshold || deltaY > pencilDragThreshold) {
            isDraggingPencil = true;
        } else {
            return;
        }
    }
    
    e.preventDefault();
    const btn = document.getElementById('text-selection-btn');
    if (!btn) return;
    
    const container = document.getElementById('reading-container');
    if (!container) return;
    
    const containerRect = container.getBoundingClientRect();
    const deltaX = e.clientX - pencilDragStartX;
    const deltaY = e.clientY - pencilDragStartY;
    
    let newX = pencilStartX + deltaX - containerRect.left;
    let newY = pencilStartY + deltaY - containerRect.top;
    
    // Keep button within container bounds
    const btnWidth = btn.offsetWidth;
    const btnHeight = btn.offsetHeight;
    newX = Math.max(0, Math.min(newX, containerRect.width - btnWidth));
    newY = Math.max(0, Math.min(newY, containerRect.height - btnHeight));
    
    btn.style.left = newX + 'px';
    btn.style.top = newY + 'px';
    btn.style.right = 'auto';
    btn.style.bottom = 'auto';
}

// Drag (touch)
function dragPencilTouch(e) {
    if (!isDraggingPencil) {
        const touch = e.touches[0];
        const deltaX = Math.abs(touch.clientX - pencilDragStartX);
        const deltaY = Math.abs(touch.clientY - pencilDragStartY);
        
        if (deltaX > pencilDragThreshold || deltaY > pencilDragThreshold) {
            isDraggingPencil = true;
        } else {
            return;
        }
    }
    
    e.preventDefault();
    const btn = document.getElementById('text-selection-btn');
    if (!btn) return;
    
    const container = document.getElementById('reading-container');
    if (!container) return;
    
    const touch = e.touches[0];
    const containerRect = container.getBoundingClientRect();
    const deltaX = touch.clientX - pencilDragStartX;
    const deltaY = touch.clientY - pencilDragStartY;
    
    let newX = pencilStartX + deltaX - containerRect.left;
    let newY = pencilStartY + deltaY - containerRect.top;
    
    const btnWidth = btn.offsetWidth;
    const btnHeight = btn.offsetHeight;
    newX = Math.max(0, Math.min(newX, containerRect.width - btnWidth));
    newY = Math.max(0, Math.min(newY, containerRect.height - btnHeight));
    
    btn.style.left = newX + 'px';
    btn.style.top = newY + 'px';
    btn.style.right = 'auto';
    btn.style.bottom = 'auto';
}

// Stop dragging (mouse)
function stopDragPencil(e) {
    const btn = document.getElementById('text-selection-btn');
    if (btn) {
        btn.classList.remove('dragging');
        
        // Save position
        if (isDraggingPencil) {
            const container = document.getElementById('reading-container');
            if (container) {
                const containerRect = container.getBoundingClientRect();
                const btnRect = btn.getBoundingClientRect();
                const pos = {
                    top: (btnRect.top - containerRect.top) + 'px',
                    right: 'auto',
                    left: (btnRect.left - containerRect.left) + 'px',
                    bottom: 'auto'
                };
                localStorage.setItem('pencilButtonPosition', JSON.stringify(pos));
            }
        }
    }
    
    document.removeEventListener('mousemove', dragPencil);
    document.removeEventListener('mouseup', stopDragPencil);
}

// Stop dragging (touch)
function stopDragPencilTouch(e) {
    const btn = document.getElementById('text-selection-btn');
    if (!btn) return;
    
    // Remove drag listeners
    document.removeEventListener('touchmove', dragPencilTouch);
    document.removeEventListener('touchmove', handlePencilTouchMove);
    
    const touchDuration = Date.now() - pencilTouchStartTime;
    const wasDrag = isDraggingPencil;
    
    if (wasDrag) {
        // Was dragging - save position
        btn.classList.remove('dragging');
        const container = document.getElementById('reading-container');
        if (container) {
            const containerRect = container.getBoundingClientRect();
            const btnRect = btn.getBoundingClientRect();
            const pos = {
                top: (btnRect.top - containerRect.top) + 'px',
                right: 'auto',
                left: (btnRect.left - containerRect.left) + 'px',
                bottom: 'auto'
            };
            localStorage.setItem('pencilButtonPosition', JSON.stringify(pos));
        }
    } else {
        // Was a tap - toggle selection mode
        // Only if it was quick (< 300ms) and no significant movement
        if (touchDuration < 300) {
            toggleTextSelection();
        }
    }
    
    // Reset drag flag
    isDraggingPencil = false;
}

// Handle click (only if not dragging)
function handlePencilClick(e) {
    // Small delay to check if it was a drag
    setTimeout(() => {
        if (!isDraggingPencil) {
            toggleTextSelection();
        }
        // Reset drag flag after a bit longer to distinguish click from drag
        setTimeout(() => {
            isDraggingPencil = false;
        }, 50);
    }, 150);
}

// Old draggable pencil initialization removed - pencil is now inside AI chat modal

// Enable text selection
function enableTextSelection() {
    const pageContent = document.getElementById('page-content');
    const readingContent = pageContent ? pageContent.querySelector('.reading-content, .section-content') : null;
    if (!pageContent) return;
    
    // Clear any previous selections
    clearSelection();
    
    // Add event listeners for text selection
    pageContent.addEventListener('mouseup', handleTextSelection);
    // For mobile, use touchend with passive: true to allow native selection
    pageContent.addEventListener('touchend', handleTextSelectionMobile, { passive: true });
    // Also listen for selection changes
    document.addEventListener('selectionchange', handleSelectionChange);
    
    // Click outside to clear selection
    document.addEventListener('click', handleClickOutside, true);
    // Also for touch
    document.addEventListener('touchend', handleClickOutsideTouch, true);
    
    // On mobile, make text more selectable by removing restrictions
    if (window.innerWidth <= 768) {
        // Remove all touch-action restrictions
        if (readingContent) {
            readingContent.style.touchAction = 'auto';
            readingContent.style.webkitTouchCallout = 'default';
            readingContent.style.touchCallout = 'default';
        }
        
        // Make sure all child elements allow selection
        const allElements = pageContent.querySelectorAll('*');
        allElements.forEach(el => {
            el.style.webkitUserSelect = 'text';
            el.style.userSelect = 'text';
            el.style.touchAction = 'auto';
            el.style.webkitTouchCallout = 'default';
        });
    }
}

// Enable text selection on chat messages
function enableChatMessagesTextSelection() {
    const chatMessages = document.getElementById('ai-chat-messages');
    if (!chatMessages) return;
    
    // Add event listeners for text selection on chat messages
    chatMessages.addEventListener('mouseup', handleTextSelection);
    chatMessages.addEventListener('touchend', handleTextSelectionMobile, { passive: true });
    
    // On mobile, make chat messages text more selectable
    if (window.innerWidth <= 768) {
        const allElements = chatMessages.querySelectorAll('*');
        allElements.forEach(el => {
            el.style.webkitUserSelect = 'text';
            el.style.userSelect = 'text';
            el.style.touchAction = 'auto';
            el.style.webkitTouchCallout = 'default';
        });
    }
}

// Disable text selection on chat messages
function disableChatMessagesTextSelection() {
    const chatMessages = document.getElementById('ai-chat-messages');
    if (!chatMessages) return;
    
    // Remove event listeners
    chatMessages.removeEventListener('mouseup', handleTextSelection);
    chatMessages.removeEventListener('touchend', handleTextSelectionMobile);
}

// Handle clicks outside selection area
function handleClickOutside(e) {
    if (!textSelectionModeActive) return;
    
    // Don't clear if we're dragging the toolbar
    if (isDraggingToolbar) return;
    
    const toolbar = document.getElementById('selection-toolbar');
    const pageContent = document.getElementById('page-content');
    const modal = document.getElementById('aiHelpModal');
    const chatMessages = document.getElementById('ai-chat-messages');
    
    // Don't clear if clicking on toolbar, modal, page content, or chat messages
    if (toolbar && toolbar.contains(e.target)) return;
    if (modal && modal.contains(e.target)) return;
    if (pageContent && pageContent.contains(e.target)) return;
    if (chatMessages && chatMessages.contains(e.target)) return;
    
    // Clear selection when clicking outside (but not when in AI chat selection mode)
    if (!aiChatSelectionModeActive) {
        clearSelection();
    }
}

// Handle touch outside selection area (mobile)
function handleClickOutsideTouch(e) {
    if (!textSelectionModeActive) return;
    
    // Don't clear if we're dragging the toolbar
    if (isDraggingToolbar) return;
    
    const toolbar = document.getElementById('selection-toolbar');
    const pageContent = document.getElementById('page-content');
    const modal = document.getElementById('aiHelpModal');
    const chatMessages = document.getElementById('ai-chat-messages');
    const target = e.target;
    
    // Don't clear if touching toolbar, modal, page content, or chat messages
    if (toolbar && toolbar.contains(target)) return;
    if (modal && modal.contains(target)) return;
    if (pageContent && pageContent.contains(target)) return;
    if (chatMessages && chatMessages.contains(target)) return;
    
    // Small delay to avoid clearing selection while user is selecting
    setTimeout(() => {
        // Check again if we're dragging (might have started during the delay)
        if (isDraggingToolbar) return;
        
        const selection = window.getSelection();
        if (!selection || selection.toString().trim().length === 0) {
            if (!aiChatSelectionModeActive) {
                clearSelection();
            }
        }
    }, 200);
}

// Disable text selection
function disableTextSelection() {
    const pageContent = document.getElementById('page-content');
    if (!pageContent) return;
    
    pageContent.removeEventListener('mouseup', handleTextSelection);
    pageContent.removeEventListener('touchend', handleTextSelectionMobile);
    document.removeEventListener('selectionchange', handleSelectionChange);
    document.removeEventListener('click', handleClickOutside, true);
    document.removeEventListener('touchend', handleClickOutsideTouch, true);
    
    const overlay = document.getElementById('touch-selection-overlay');
    if (overlay) {
        overlay.classList.remove('active');
    }
    
    clearSelection();
}

// Always-on selection toolbar for AI spark
function initSelectionToolbarAlwaysOn() {
    if (!selectionToolbarAlwaysOn) return;
    textSelectionModeActive = true;
    enableTextSelection();
}

// Handle text selection (desktop)
function handleTextSelection(e) {
    if (!textSelectionModeActive) return;
    
    setTimeout(() => {
        const selection = window.getSelection();
        if (selection && selection.toString().trim().length > 0) {
            // Expand selection to complete words only (not sentences)
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0).cloneRange();
                
                // Use manual expansion to word boundaries only (not sentences)
                // This gives us precise control and prevents sentence expansion
                expandRangeToWords(range);
                selection.removeAllRanges();
                selection.addRange(range);
                selectedRange = range.cloneRange();
            }
            
            selectedText = selection.toString().trim();
            
            // Don't apply custom highlight on desktop - use native browser selection
            // Native selection already has yellow highlight via CSS ::selection
            // Custom highlighting causes layout issues with extra spacing
            
            // If selection mode is active from AI chat, show status indicator
            if (aiChatSelectionModeActive) {
                updateAIChatSelectionStatus(selectedText);
            } else {
                // Old behavior: show floating toolbar (kept for backwards compatibility)
                // Hide toolbar when in AI chat mode
                showSelectionToolbar(e);
            }
        } else {
            // If selection is cleared, hide toolbar
            setTimeout(() => {
                const currentSelection = window.getSelection();
                if (!currentSelection || currentSelection.toString().trim().length === 0) {
                    clearSelection();
                }
            }, 100);
        }
    }, 10);
}

// Expand range to word boundaries (fallback method)
function expandRangeToWords(range) {
    try {
        // Get the full text content of the range's common ancestor
        const container = range.commonAncestorContainer;
        let text = '';
        let startOffset = range.startOffset;
        let endOffset = range.endOffset;
        
        // If container is a text node, use it directly
        if (container.nodeType === Node.TEXT_NODE) {
            text = container.textContent || '';
        } else {
            // If container is an element, get all text content
            text = container.textContent || '';
            
            // For element containers, we need to find text nodes
            // Simple approach: use the range's text content and expand within it
            const rangeText = range.toString();
            const containerText = container.textContent || '';
            
            // Find the range text in the container text
            const rangeStart = containerText.indexOf(rangeText);
            if (rangeStart !== -1) {
                startOffset = rangeStart;
                endOffset = rangeStart + rangeText.length;
            }
        }
        
        // Expand start backwards to word boundary
        while (startOffset > 0 && /\w/.test(text[startOffset - 1])) {
            startOffset--;
        }
        
        // Expand end forwards to word boundary  
        while (endOffset < text.length && /\w/.test(text[endOffset])) {
            endOffset++;
        }
        
        // Try to set the range - need to handle text nodes properly
        if (container.nodeType === Node.TEXT_NODE) {
            range.setStart(container, startOffset);
            range.setEnd(container, endOffset);
        } else {
            // For element containers, find the text node
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null
            );
            
            let textNode = walker.nextNode();
            let charCount = 0;
            let startNode = null;
            let endNode = null;
            let startNodeOffset = 0;
            let endNodeOffset = 0;
            
            while (textNode) {
                const nodeLength = textNode.textContent.length;
                const nodeStart = charCount;
                const nodeEnd = charCount + nodeLength;
                
                if (!startNode && startOffset >= nodeStart && startOffset <= nodeEnd) {
                    startNode = textNode;
                    startNodeOffset = startOffset - nodeStart;
                }
                
                if (!endNode && endOffset >= nodeStart && endOffset <= nodeEnd) {
                    endNode = textNode;
                    endNodeOffset = endOffset - nodeStart;
                }
                
                if (startNode && endNode) break;
                
                charCount += nodeLength;
                textNode = walker.nextNode();
            }
            
            if (startNode && endNode) {
                range.setStart(startNode, startNodeOffset);
                range.setEnd(endNode, endNodeOffset);
            }
        }
    } catch (err) {
        console.log('Error expanding to words:', err);
    }
}

// Handle text selection (mobile)
function handleTextSelectionMobile(e) {
    if (!textSelectionModeActive) return;
    
    // Don't prevent default - let native selection work
    // Wait for native selection to complete
    setTimeout(() => {
        const selection = window.getSelection();
        if (selection && selection.toString().trim().length > 0) {
            // Expand selection to complete words only (not sentences)
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0).cloneRange();
                
                // Use manual expansion to word boundaries only (not sentences)
                expandRangeToWords(range);
                selection.removeAllRanges();
                selection.addRange(range);
                selectedRange = range.cloneRange();
            }
            
            selectedText = selection.toString().trim();
            
            // If selection mode is active from AI chat, show status indicator
            if (aiChatSelectionModeActive) {
                updateAIChatSelectionStatus(selectedText);
            } else {
                // Old behavior: show floating toolbar (kept for backwards compatibility)
                const touch = e.changedTouches && e.changedTouches[0];
                const eventForToolbar = touch ? {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                } : e;
                showSelectionToolbar(eventForToolbar);
            }
        }
    }, 200); // Longer delay for mobile to ensure selection is complete
}

// Handle selection change (when user clicks elsewhere)
function handleSelectionChange() {
    if (!textSelectionModeActive) return;
    
    // Don't clear if we're dragging the toolbar
    if (isDraggingToolbar) return;
    
    setTimeout(() => {
        // Check again if we're dragging (might have started during the delay)
        if (isDraggingToolbar) return;
        
        const selection = window.getSelection();
        if (!selection || selection.toString().trim().length === 0) {
            // If in AI chat selection mode, don't clear automatically
            if (aiChatSelectionModeActive) {
                updateAIChatSelectionStatus('');
                return;
            }
            
            // Check if click was outside the page content
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar && !toolbar.contains(document.activeElement)) {
                // Don't clear if clicking on toolbar
                const clickedElement = document.activeElement;
                if (!toolbar.contains(clickedElement)) {
                    clearSelection();
                }
            }
        }
    }, 200);
}

// Highlight selected text (works better on mobile)
function highlightSelectedText(range) {
    if (!range) return;
    
    // Clear previous highlights first
    clearHighlights();
    
    try {
        // Use a more robust highlighting method that works across multiple nodes
        // This is better for mobile selections that may span multiple elements
        
        const contents = range.extractContents();
        
        // Create highlight span
        const highlightSpan = document.createElement('span');
        highlightSpan.className = 'text-highlighted';
        highlightSpan.setAttribute('data-selected-text', selectedText);
        
        // Wrap all contents in the highlight span
        highlightSpan.appendChild(contents);
        
        // Insert the highlighted span back
        range.insertNode(highlightSpan);
        
        // Normalize to merge adjacent text nodes
        if (highlightSpan.parentNode) {
            highlightSpan.parentNode.normalize();
        }
    } catch (e) {
        // If that fails, try simpler approach
        try {
            const span = document.createElement('span');
            span.className = 'text-highlighted';
            span.setAttribute('data-selected-text', selectedText);
            
            // For simple selections, use surroundContents
            if (range.collapsed === false) {
                range.surroundContents(span);
            }
        } catch (e2) {
            // If all else fails, the native browser selection will show
            console.log('Using native selection highlight');
        }
    }
}

// Clear highlights
function clearHighlights() {
    const highlights = document.querySelectorAll('.text-highlighted');
    highlights.forEach(highlight => {
        try {
            const parent = highlight.parentNode;
            if (parent) {
                // Move all child nodes back to parent
                while (highlight.firstChild) {
                    parent.insertBefore(highlight.firstChild, highlight);
                }
                parent.removeChild(highlight);
                parent.normalize(); // Merge adjacent text nodes
            }
        } catch (e) {
            console.log('Error clearing highlight:', e);
        }
    });
}

// Show selection toolbar
function showSelectionToolbar(e) {
    const toolbar = document.getElementById('selection-toolbar');
    
    if (!toolbar || !selectedText) return;
    
    // Position toolbar
    let x, y;
    const isMobile = window.innerWidth <= 768;
    
    if (isMobile) {
        // Mobile: position at bottom center
        toolbar.style.left = '';
        toolbar.style.right = '';
        toolbar.style.top = '';
        toolbar.style.bottom = '20px';
        toolbar.style.left = '10px';
        toolbar.style.right = '10px';
        toolbar.style.width = 'auto';
    } else {
        // Desktop: position near cursor or selection
        if (e && e.clientX && e.clientY) {
            x = e.clientX;
            y = e.clientY - 60; // Above cursor
        } else {
            // Position near the selection
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0) {
                const rect = selection.getRangeAt(0).getBoundingClientRect();
                x = rect.left + rect.width / 2;
                y = rect.top - 60;
            } else {
                x = window.innerWidth / 2;
                y = window.innerHeight / 2;
            }
        }
        
        // Keep toolbar within viewport
        const toolbarWidth = 300;
        const toolbarHeight = 60;
        x = Math.max(10, Math.min(x, window.innerWidth - toolbarWidth - 10));
        y = Math.max(10, Math.min(y, window.innerHeight - toolbarHeight - 10));
        
        toolbar.style.left = (x - toolbarWidth / 2) + 'px';
        toolbar.style.top = y + 'px';
        toolbar.style.bottom = '';
        toolbar.style.right = '';
        toolbar.style.width = toolbarWidth + 'px';
    }
    
    toolbar.classList.add('show');
    
    // Initialize drag functionality
    initSelectionToolbarDrag();
}

// Drag state for selection toolbar
let isDraggingToolbar = false;
let toolbarDragStartX = 0;
let toolbarDragStartY = 0;
let toolbarStartX = 0;
let toolbarStartY = 0;
let toolbarHasMoved = false;

// Initialize drag functionality for selection toolbar
function initSelectionToolbarDrag() {
    const toolbar = document.getElementById('selection-toolbar');
    if (!toolbar) return;
    
    // Check if already initialized
    if (toolbar.dataset.dragInitialized === 'true') return;
    toolbar.dataset.dragInitialized = 'true';
    
    // Make icon and bubble draggable (but not close button)
    const aiBtn = toolbar.querySelector('.selection-ai-btn');
    const aiBubble = toolbar.querySelector('.selection-ai-bubble');
    const closeBtn = toolbar.querySelector('.selection-ai-close');
    
    // Add click handlers that check if we dragged
    if (aiBtn) {
        aiBtn.addEventListener('mousedown', startToolbarDrag);
        aiBtn.addEventListener('touchstart', startToolbarDragTouch, { passive: false });
        aiBtn.addEventListener('click', function(e) {
            if (!toolbarHasMoved) {
                openAIHelpWithSelection();
            }
        });
    }
    
    if (aiBubble) {
        aiBubble.addEventListener('mousedown', function(e) {
            // Don't start drag if clicking close button
            if (e.target.classList.contains('selection-ai-close') || e.target.closest('.selection-ai-close')) {
                return;
            }
            startToolbarDrag(e);
        });
        aiBubble.addEventListener('touchstart', function(e) {
            if (e.target.classList.contains('selection-ai-close') || e.target.closest('.selection-ai-close')) {
                return;
            }
            startToolbarDragTouch(e);
        }, { passive: false });
        aiBubble.addEventListener('click', function(e) {
            if (!toolbarHasMoved && !e.target.classList.contains('selection-ai-close') && !e.target.closest('.selection-ai-close')) {
                openAIHelpWithSelection();
            }
        });
    }
    
    if (closeBtn) {
        closeBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            clearSelection();
        });
    }
    
    function startToolbarDrag(e) {
        isDraggingToolbar = true;
        toolbarHasMoved = false;
        toolbarDragStartX = e.clientX;
        toolbarDragStartY = e.clientY;
        const rect = toolbar.getBoundingClientRect();
        toolbarStartX = rect.left;
        toolbarStartY = rect.top;
        toolbar.classList.add('dragging');
        // Don't preventDefault here - allow click if no movement
        e.stopPropagation();
        
        document.addEventListener('mousemove', dragToolbar);
        document.addEventListener('mouseup', stopToolbarDrag);
    }
    
    function startToolbarDragTouch(e) {
        const touch = e.touches[0];
        isDraggingToolbar = true;
        toolbarHasMoved = false;
        toolbarDragStartX = touch.clientX;
        toolbarDragStartY = touch.clientY;
        const rect = toolbar.getBoundingClientRect();
        toolbarStartX = rect.left;
        toolbarStartY = rect.top;
        toolbar.classList.add('dragging');
        // Don't preventDefault here - allow click if no movement
        e.stopPropagation();
        
        document.addEventListener('touchmove', dragToolbarTouch, { passive: false });
        document.addEventListener('touchend', stopToolbarDrag);
    }
    
    function dragToolbar(e) {
        if (!isDraggingToolbar) return;
        const deltaX = e.clientX - toolbarDragStartX;
        const deltaY = e.clientY - toolbarDragStartY;
        
        // Check if moved more than 5px (to distinguish from click)
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
            toolbarHasMoved = true;
        }
        
        toolbar.style.left = (toolbarStartX + deltaX) + 'px';
        toolbar.style.top = (toolbarStartY + deltaY) + 'px';
        toolbar.style.bottom = '';
        toolbar.style.right = '';
        toolbar.style.width = '';
        
        // Prevent default to avoid clearing selection
        e.preventDefault();
        e.stopPropagation();
    }
    
    function dragToolbarTouch(e) {
        if (!isDraggingToolbar) return;
        const touch = e.touches[0];
        const deltaX = touch.clientX - toolbarDragStartX;
        const deltaY = touch.clientY - toolbarDragStartY;
        
        // Check if moved more than 5px
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
            toolbarHasMoved = true;
        }
        
        toolbar.style.left = (toolbarStartX + deltaX) + 'px';
        toolbar.style.top = (toolbarStartY + deltaY) + 'px';
        toolbar.style.bottom = '';
        toolbar.style.right = '';
        toolbar.style.width = '';
        
        // Prevent default to avoid clearing selection
        e.preventDefault();
        e.stopPropagation();
    }
    
    function stopToolbarDrag(e) {
        if (isDraggingToolbar) {
            const wasDragging = toolbarHasMoved;
            isDraggingToolbar = false;
            toolbar.classList.remove('dragging');
            document.removeEventListener('mousemove', dragToolbar);
            document.removeEventListener('mouseup', stopToolbarDrag);
            document.removeEventListener('touchmove', dragToolbarTouch);
            document.removeEventListener('touchend', stopToolbarDrag);
            
            // If we actually dragged, prevent the click event
            if (wasDragging && e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Reset flag after a short delay to allow click handlers to check it
            setTimeout(() => {
                toolbarHasMoved = false;
            }, 100);
        }
    }
}

// Clear selection
function clearSelection() {
    // Don't clear if we're dragging the toolbar
    if (isDraggingToolbar) return;
    
    selectedText = '';
    selectedRange = null;
    
    const toolbar = document.getElementById('selection-toolbar');
    if (toolbar) {
        toolbar.classList.remove('show');
        // Reset drag initialization so it can be reinitialized next time
        toolbar.dataset.dragInitialized = 'false';
    }
    
    // Clear AI chat selection status
    if (aiChatSelectionModeActive) {
        updateAIChatSelectionStatus('');
    }
    
    clearHighlights();
    
    // Clear browser selection
    const selection = window.getSelection();
    if (selection) {
        selection.removeAllRanges();
    }
}

// Open AI Help with selected text
function openAIHelpWithSelection() {
    // Save the selected text before any clearing operations
    const textToUse = selectedText;
    
    if (!textToUse) {
        alert('No text selected. Please select some text first.');
        return;
    }
    
    console.log('[openAIHelpWithSelection] Selected text:', textToUse);
    
    // Clear selection visuals (but keep the text saved above)
    clearHighlights();
    const toolbar = document.getElementById('selection-toolbar');
    if (toolbar) {
        toolbar.classList.remove('show');
    }
    
    // Clear browser selection visually
    const selection = window.getSelection();
    if (selection) {
        selection.removeAllRanges();
    }
    
    // Format the question with saved text
    const question = `Help me understand this: "${textToUse}"`;
    console.log('[openAIHelpWithSelection] Question:', question);
    
    // Open AI Help modal and set the question
    const modalElement = document.getElementById('aiHelpModal');
    if (!aiHelpModalInstance) {
        aiHelpModalInstance = new bootstrap.Modal(modalElement, {
            backdrop: 'static',
            keyboard: true
        });
        modalElement.addEventListener('hidden.bs.modal', function() {
            disableAIChatTextSelection();
            aiHelpModalInstance = null;
            // Re-init always-on selection toolbar when modal closes
            if (selectionToolbarAlwaysOn) {
                initSelectionToolbarAlwaysOn();
            }
        }, { once: false });
    }
    aiHelpModalInstance.show();
    
    // Reset modal to default size when opening
    const modalDialog2 = document.getElementById('aiHelpModalDialog');
    if (modalDialog2) {
        modalDialog2.style.width = '520px';
        modalDialog2.style.height = '330px';
    }

    // Initialize drag and resize for the modal
    setTimeout(() => {
        initAIHelpModalDrag();
        initAIHelpModalResize();
    }, 300);

    // Set the question in the input after a short delay
    setTimeout(() => {
        const questionInput = document.getElementById('ai-question');
        if (questionInput) {
            questionInput.value = question;
            questionInput.focus();
            console.log('[openAIHelpWithSelection] Set question input to:', question);
            // Trigger auto-resize
            questionInput.style.height = 'auto';
            questionInput.style.height = Math.min(questionInput.scrollHeight, 120) + 'px';
        } else {
            console.error('[openAIHelpWithSelection] Could not find ai-question input!');
        }
    }, 600);
    
    // Reset the global selectedText variable
    selectedText = '';
}

// Handle chat input keyboard events
function handleChatInputKeydown(e) {
    // If selection mode is active and Enter is pressed, copy selected text to input
    if (aiChatSelectionModeActive && e.key === 'Enter' && !e.shiftKey && selectedText) {
        e.preventDefault();
        copySelectedTextToChatInput();
        return;
    }
    
    // Otherwise, normal behavior: Enter sends message
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        askAI();
    }
}

// Copy selected text to chat input field
function copySelectedTextToChatInput() {
    if (!selectedText) return;
    
    const questionInput = document.getElementById('ai-question');
    if (!questionInput) return;
    
    // Set the selected text in the input
    questionInput.value = selectedText;
    
    // Auto-resize textarea
    questionInput.style.height = 'auto';
    questionInput.style.height = Math.min(questionInput.scrollHeight, 120) + 'px';
    
    // Clear selection and exit selection mode
    clearSelection();
    disableAIChatTextSelection(); // Turn off selection mode
    
    // Focus on input
    questionInput.focus();
    // Move cursor to end
    questionInput.setSelectionRange(questionInput.value.length, questionInput.value.length);
}

// Update AI chat selection status indicator
function updateAIChatSelectionStatus(text) {
    const statusDiv = document.getElementById('ai-chat-selection-status');
    const statusText = document.getElementById('ai-chat-selection-status-text');
    
    if (statusDiv && statusText) {
        if (text && text.trim().length > 0) {
            const previewText = text.length > 60 ? text.substring(0, 60) + '...' : text;
            statusText.textContent = `Selected: "${previewText}" - Press Enter to add to chat`;
            statusDiv.style.display = 'block';
            statusDiv.classList.remove('text-muted');
            statusDiv.classList.add('text-success', 'fw-bold');
        } else {
            statusDiv.style.display = 'none';
        }
    }
}

function requestHelp() {
    const content = prompt('What do you need help with?');
    if (content) {
        const token = getAuthToken();
        fetch('/auth/v1/user', {
            headers: {'Authorization': 'Bearer ' + token}
        })
        .then(res => res.json())
        .then(user => {
            return fetch('/rest/v1/help_requests?select=*', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + token
                },
                body: JSON.stringify({
                    user_id: user.id,
                    book_id: bookId,
                    content: content,
                    status: 'pending'
                })
            });
        })
        .then(res => res.json())
        .then(data => {
            alert('Help request submitted successfully!');
            // Track activity with both help_request_id and content for better retrieval
            trackActivity('HELP_REQUEST', { 
                help_request_id: data[0]?.id,
                content: content
            });
        })
        .catch(err => {
            alert('Failed to submit help request');
        });
    }
}

// Load first page on page load
document.addEventListener('DOMContentLoaded', function() {
    console.log('[interaction.html] ========== DOMContentLoaded fired ==========');
    console.log('[interaction.html] Checking if functions are defined...');
    console.log('[interaction.html] loadGlossaryTerms:', typeof loadGlossaryTerms);
    console.log('[interaction.html] loadPage:', typeof loadPage);
    console.log('[interaction.html] getAuthToken:', typeof getAuthToken);
    
    // Attach logout handler (backup - app.js also handles this via event delegation)
    const logoutLink = document.getElementById('logout-link-reader');
    if (logoutLink) {
        console.log('[interaction.html] Found logout link, attaching handler');
        logoutLink.addEventListener('click', function(e) {
            e.preventDefault();
            console.log('[interaction.html] Logout clicked');
            if (window.logout) {
                console.log('[interaction.html] Calling window.logout()');
                window.logout();
            } else {
                console.error('[interaction.html] window.logout is not defined!');
            }
        });
    } else {
        console.warn('[interaction.html] Logout link not found');
    }

    // User info is loaded by app.js automatically
    // But let's also try loading it here as a backup
    setTimeout(function() {
        if (typeof loadUserInfoInNavbar === 'function') {
            console.log('[interaction.html] Calling loadUserInfoInNavbar() as backup');
            loadUserInfoInNavbar();
        }
    }, 100);
    
    // Ensure DOM elements exist before loading page
    const pageContentElement = document.getElementById('page-content');
    const sectionSnippetsElement = document.getElementById('section-snippets');
    
    if (!pageContentElement) {
        console.error('[interaction.html] page-content element not found!');
    }
    if (!sectionSnippetsElement) {
        console.error('[interaction.html] section-snippets element not found!');
    }
    
    console.log('[interaction.html] Loading initial page...');
    console.log('[interaction.html] About to call loadGlossaryTerms...');
    console.log('[interaction.html] loadGlossaryTerms function exists?', typeof loadGlossaryTerms);
    
    // Load glossary terms for highlighting, then load page
    if (typeof loadGlossaryTerms === 'function') {
        loadGlossaryTerms().then(() => {
            console.log('[interaction.html] loadGlossaryTerms completed, loading page...');
            loadPage(1);
            initSelectionToolbarAlwaysOn();
        }).catch(err => {
            console.error('[interaction.html] Error in loadGlossaryTerms promise:', err);
            // Still load page even if glossary fails
            loadPage(1);
            initSelectionToolbarAlwaysOn();
        });
    } else {
        console.error('[interaction.html] loadGlossaryTerms is not a function!');
        // Load page anyway
        loadPage(1);
        initSelectionToolbarAlwaysOn();
    }
});

// Also try loading if DOM is already ready (for cases where script loads after DOMContentLoaded)
if (document.readyState === 'loading') {
    // DOM is still loading, wait for DOMContentLoaded (handled above)
    console.log('[interaction.html] DOM is still loading, waiting for DOMContentLoaded');
} else {
    // DOM is already loaded
    console.log('[interaction.html] DOM already loaded, loading page immediately');
    const pageContentElement = document.getElementById('page-content');
    const sectionSnippetsElement = document.getElementById('section-snippets');
    
    if (pageContentElement && sectionSnippetsElement) {
        console.log('[interaction.html] Elements found, loading page');
        if (typeof loadGlossaryTerms === 'function') {
            loadGlossaryTerms().then(() => {
                console.log('[interaction.html] loadGlossaryTerms completed (second call), loading page...');
                loadPage(1);
                initSelectionToolbarAlwaysOn();
            }).catch(err => {
                console.error('[interaction.html] Error in loadGlossaryTerms promise (second call):', err);
                loadPage(1);
                initSelectionToolbarAlwaysOn();
            });
        } else {
            console.error('[interaction.html] loadGlossaryTerms is not a function (second call)!');
            loadPage(1);
            initSelectionToolbarAlwaysOn();
        }
    } else {
        console.warn('[interaction.html] Elements not found yet, will wait for DOMContentLoaded');
    }
}
</script>
{{end}}
